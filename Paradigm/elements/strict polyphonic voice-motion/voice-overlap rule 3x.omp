; OM File Header - Saved 2022/12/22 2:31:13
; (6.16 :patc (om-make-point 1161.9688 490) (om-make-point 50 50) (om-make-point 377 297) "" 908 0 "2022/12/11 22:50:31" "2022/12/20 23:20:29")
; End File Header
(in-package :om)(load-lib-for (quote ("myextension")))(setf *om-current-persistent* (om-load-patch1 "voice-overlap rule 3x" (quote ((let ((box (om-load-boxcall (quote abstraction) "apply condition to adjacent pairs of voices" (om-load-patch-abs1 "apply condition to adjacent pairs of voices" (quote ((let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 354 111) (om-make-point 26 28) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 345 111) (om-make-point 26 28) 2 "2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "NSUCC" (quote nsucc) (quote ((om-load-inputfun (quote input-funbox) "" "INPUT" nil) (om-load-inputfun (quote input-funbox) "" "N" nil) (om-load-inputkeyword (quote input-keyword) "" "step" (quote :step) nil nil))) (om-make-point 331 141) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAP?AND" (quote map?and) (quote ((om-load-inputfun (quote input-funbox) "" "FN" nil) (om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 276 215) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 142 317) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 50 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "mypatch" (quote ((let ((box (om-load-boxcall (quote genfun) "MAP?AND" (quote map?and) (quote ((om-load-inputfun (quote input-funbox) "" "FN" nil) (om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 199 315) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 4" (quote t) (quote nil) (om-make-point 262 186) (om-make-point 26 28) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 253 186) (om-make-point 26 28) 2 "2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "NSUCC 2" (quote nsucc) (quote ((om-load-inputfun (quote input-funbox) "" "INPUT" nil) (om-load-inputfun (quote input-funbox) "" "N" nil) (om-load-inputkeyword (quote input-keyword) "" "step" (quote :step) nil nil))) (om-make-point 239 216) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FLATTEN-SEQC" (quote t2l::flatten-seqc) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 52 109) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 97 170) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "mypatch" (quote ((let ((box (om-load-boxcall (quote abstraction) "mypatch 2" (om-load-patch-abs1 "mypatch 2" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 169 285) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 50 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CAR" (quote car) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 174 121) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CADR" (quote cadr) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 245 121) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "mypatch" (quote ((let ((box (om-load-boxcall (quote genfun) "?NOT 2" (quote ?not) (quote ((om-load-inputfun (quote input-funbox) "" "X" nil))) (om-make-point 248 209) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?>" (quote ?>) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 254 154) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?LISTMAX 2" (quote ?listmax) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 256 86) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?LISTMIN 2" (quote ?listmin) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 212 86) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?LISTMIN" (quote ?listmin) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 152 86) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?LISTMAX" (quote ?listmax) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 106 86) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?<" (quote ?<) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 149 154) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?NOT" (quote ?not) (quote ((om-load-inputfun (quote input-funbox) "" "X" nil))) (om-make-point 143 209) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?AND" (quote ?and) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 218 260) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 104 338) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord2" 1 (om-make-point 289 8) "" "chord2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord1" 0 (om-make-point 84 24) "" "chord1" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (3 0 1 0 nil 0) (2 0 1 1 nil 0) (10 0 2 0 nil 0) (11 0 3 0 nil 0) (10 0 4 0 nil 0) (11 0 5 0 nil 0) (5 0 6 0 nil 0) (4 0 6 1 nil 0) (6 0 7 0 nil 0) (7 0 8 0 nil 0) (0 0 8 1 nil 0) (8 0 9 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 380)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 1721/9 1567/9) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((4 0 0 0 nil 0) (1 0 2 0 nil 0) (1 0 3 0 nil 0) (2 0 4 0 nil 0) (3 0 4 1 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 370 350)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 4250/27 3664/27) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "HAS-NULL-VALUES" (quote has-null-values) (quote ((om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 0 197) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 65 252) (om-make-point 26 28) (quote t) "T" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 53 282) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 21 131) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 111 41) (quote "((x1 x2) (y1 y2)") "" (om-make-point 126 23) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 4 47) "" nil (list (list (quote x1) (quote x2)) (list (quote y1) (quote y2))) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 5 410) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((6 0 0 0 nil 0) (4 0 1 0 nil 0) (1 0 3 0 nil 0) (2 0 3 1 nil 0) (0 0 3 2 nil 0) (6 0 4 0 nil 0) (3 0 7 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 320)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 37 232) nil (list nil) "l" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 5 380) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((6 0 0 0 nil 0) (3 0 0 1 nil 0) (5 0 3 0 nil 0) (2 0 3 1 nil 0) (1 0 3 2 nil 0) (8 0 4 0 nil 0) (4 0 5 0 nil 0) (0 0 7 0 nil 0))) 6.16 nil "" (om-make-point 541 251) (om-make-point 500 360)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 134 129) nil nil "l" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((5 0 2 0 nil 0) (1 0 2 1 nil 0) (0 0 2 2 nil 0) (6 0 3 0 nil 0) (2 0 3 1 nil 0) (3 0 4 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 708 402)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 686/5 663/5) nil nil nil "apply condition to adjacent pairs of voices"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "sequence has 1 voice" (om-load-patch-abs1 "sequence has 1 voice" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 72 317) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 50 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 50 197) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 78 238) (om-make-point 26 28) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 68 268) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((4 0 0 0 nil 0) (1 0 2 0 nil 0) (2 0 4 0 nil 0) (3 0 4 1 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 203 364)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 0 448/3) nil nil nil "sequence has 1 voice"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 4" (quote t) (quote nil) (om-make-point 57 212) (om-make-point 26 28) (quote t) "T" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 27 242) (om-make-point 68 56) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 18 307) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" "input" (list 60 62 64) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((5 0 0 0 nil 0) (5 0 1 0 nil 0) (1 0 3 0 nil 0) (2 0 3 1 nil 0) (0 0 3 2 nil 0) (3 0 4 0 nil 0))) nil 6.16))
