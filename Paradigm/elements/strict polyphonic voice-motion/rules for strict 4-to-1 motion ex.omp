; OM File Header - Saved 2023/10/26 13:44:47
; (6.16 :patc (om-make-point 66.0 10) (om-make-point 280 0) (om-make-point 1070 480) "" 908 0 nil "2023/10/26 13:44:47")
; End File Header
; External resources 
; (list (list (quote :abstraction) "#P\"is a step or a repeat.omp\"" "#P\"is open.omp\"" "#P\"is consonant.omp\"" "#P\"no voice should make a leap greater than a 5th except with an ascending m6 - 1 input.omp\"" "#P\"voice-overlap rule - 1-input.omp\"" "#P\"voice-escmotion folder/1to4-motion.omp\"" "#P\"voice-escmotion folder/is 1to4.omp\"" "#P\"voice-escmotion 3.omp\"" "#P\"voice-escmotion folder/is 1to2.omp\"" "#P\"voice-escmotion folder/1to2-motion.omp\"" "#P\"tritones across voices.omp\"" "#P\"similar motion into open intervals.omp\"" "#P\"transposition.omp\"" "#P\"leaps to octaves 2.omp\"" "#P\"consecutive open intervals 2.omp\"" "#P\"voice-overlap and spacing.omp\"" "#P\"prepared cadence rule 2.omp\"" "#P\"unison ending rule 2.omp\"" "#P\"rule template.omp\"" "#P\"tritone leaps.omp\""))
(in-package :om)(load-lib-for (quote ("myextension")))(setf *om-current-persistent* (om-load-patch1 "rules for strict 4-to-1 motion ex" (quote ((let ((box (om-load-boxcall (quote abstraction) "leaps to octaves 2" (om-load-patch-abs1 "leaps to octaves 2" (quote ((let ((box (om-load-boxwithed1 (quote box-with-win) "as 1st species" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" nil))) (om-make-point 300 20) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS 3" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 24 127) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS 2" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 293 444) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CAR" (quote car) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 276 315) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REMOVE-IF" (quote remove-if) (quote ((om-load-inputfun (quote input-funbox) "PREDICATE" "PREDICATE" nil) (om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 278 249) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NULL" (quote null) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 248 155) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "SOME" (quote some) (quote ((om-load-inputfun (quote input-funbox) "PREDICATE" "PREDICATE" nil) (om-load-inputfun (quote input-funbox) "FIRST-SEQUENCE" "FIRST-SEQUENCE" nil))) (om-make-point 262 202) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 306 186) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FLATTEN-SEQC" (quote t2l::flatten-seqc) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 302 141) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 255 379) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 12 205) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "sequence" 0 (om-make-point 5 40) "" "sequence" (list (list 60 67 60 59) (list 72 71 72 74) (list 76 74 76 74)) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 300 510) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 200 510) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((10 0 0 0 nil 0) (8 1 1 0 nil 0) (3 0 2 0 nil 0) (5 0 3 0 nil 0) (6 0 3 1 nil 0) (4 0 5 0 nil 0) (7 0 6 0 nil 0) (9 0 7 0 nil 0) (2 0 8 0 nil 0) (0 0 9 0 nil 0) (1 0 11 0 nil 0) (8 0 12 0 nil 0))) 1 "as 1st species" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "mypatch" (quote ((let ((box (om-load-boxcall (quote genfun) "HAS-NULL-VALUES" (quote has-null-values) (quote ((om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 211 72) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REMOVE-IF" (quote remove-if) (quote ((om-load-inputfun (quote input-funbox) "PREDICATE" "PREDICATE" nil) (om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 270 135) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "mypatch" (quote ((let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "mypatch" (quote ((let ((box (om-load-boxcall (quote patch-box) "is a step or a repeat" (quote ("elements" "paradigms" "myparadigm 3" "is a step or a repeat")) (quote ((om-load-inputfun (quote input-funbox) "" "x1" nil) (om-load-inputfun (quote input-funbox) "" "x2" nil))) (om-make-point 526 316) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is a step or a repeat" (quote ("elements" "paradigms" "myparadigm 3" "is a step or a repeat")) (quote ((om-load-inputfun (quote input-funbox) "" "x1" nil) (om-load-inputfun (quote input-funbox) "" "x2" nil))) (om-make-point 398 311) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS 2" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 533 166) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS 2" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 412 165) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS 2" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 467 100) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 456 31) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?AND" (quote ?and) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 310 183) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?OR" (quote ?or) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 292 258) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?NOT" (quote ?not) (quote ((om-load-inputfun (quote input-funbox) "" "X" nil))) (om-make-point 235 222) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 215 81) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 74 73) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 200 357) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 88 0) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is open" (quote ("elements" "paradigms" "myparadigm 3" "is open")) (quote ((om-load-inputfun (quote input-funbox) "" "x" 67) (om-load-inputfun (quote input-funbox) "" "y" 60))) (om-make-point 229 146) nil nil "&" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 0 0 nil 0) (2 1 0 1 nil 0) (3 0 1 0 nil 0) (3 1 1 1 nil 0) (4 1 2 0 nil 0) (4 0 3 0 nil 0) (5 0 4 0 nil 0) (12 0 5 0 nil 0) (13 0 6 0 nil 0) (1 0 6 1 nil 0) (0 0 6 2 nil 0) (8 0 7 0 nil 0) (6 0 7 1 nil 0) (13 0 8 0 nil 0) (10 1 9 0 nil 0) (12 0 10 0 nil 0) (7 0 11 0 nil 0) (9 0 13 0 nil 0) (9 1 13 1 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 187 33) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CDR" (quote cdr) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 31 133) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 127 200) (om-make-point 26 28) (quote t) "T" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 107 230) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 19 315) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((5 0 0 0 nil 0) (5 0 1 0 nil 0) (1 0 3 0 nil 0) (0 0 3 1 nil 0) (2 0 3 2 nil 0) (3 0 4 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 172 120) nil nil "l" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAPLIST?AND" (quote maplist?and) (quote ((om-load-inputfun (quote input-funbox) "" "FN" nil) (om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 186 192) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 299 72) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FLATTEN-SEQC" (quote flatten-seqc) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 292 17) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 16 356) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((0 0 1 0 nil 0) (4 0 1 1 nil 0) (2 0 3 0 nil 0) (1 0 3 1 nil 0) (5 0 4 0 nil 0) (7 0 5 0 nil 0) (3 0 6 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 98 184) nil nil "l" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAP?AND" (quote map?and) (quote ((om-load-inputfun (quote input-funbox) "" "FN" nil) (om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 164 261) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "COMBINATIONS-OF2" (quote combinations-of2) (quote ((om-load-inputfun (quote input-funbox) "XS" "XS" nil))) (om-make-point 185 194) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 193 341) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 50 77) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((5 0 0 0 nil 0) (1 0 2 0 nil 0) (3 0 2 1 nil 0) (0 0 3 0 nil 0) (2 0 4 0 nil 0))) 6.16 nil "" (om-make-point 426 179) (om-make-point 500 380)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 660 180) nil nil "l" "leaps to octaves"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "consonant vertical intervals - 1st species" (om-load-patch-abs1 "consonant vertical intervals - 1st species" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 610 471) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 50 108) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "as 1st species 2" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" nil))) (om-make-point 702 50) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS 3" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 24 127) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS 2" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 293 444) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CAR" (quote car) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 276 315) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REMOVE-IF" (quote remove-if) (quote ((om-load-inputfun (quote input-funbox) "PREDICATE" "PREDICATE" nil) (om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 278 249) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NULL" (quote null) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 248 155) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "SOME" (quote some) (quote ((om-load-inputfun (quote input-funbox) "PREDICATE" "PREDICATE" nil) (om-load-inputfun (quote input-funbox) "FIRST-SEQUENCE" "FIRST-SEQUENCE" nil))) (om-make-point 262 202) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 306 186) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FLATTEN-SEQC" (quote t2l::flatten-seqc) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 302 141) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 255 379) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 12 205) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "sequence" 0 (om-make-point 5 40) "" "sequence" (list (list 60 67 60 59) (list 72 71 72 74) (list 76 74 76 74)) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 300 510) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 200 510) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((10 0 0 0 nil 0) (8 1 1 0 nil 0) (3 0 2 0 nil 0) (5 0 3 0 nil 0) (6 0 3 1 nil 0) (4 0 5 0 nil 0) (7 0 6 0 nil 0) (9 0 7 0 nil 0) (2 0 8 0 nil 0) (0 0 9 0 nil 0) (1 0 11 0 nil 0) (8 0 12 0 nil 0))) 1 "as 1st species" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "consonant vertical intervals" (om-load-patch-abs1 "consonant vertical intervals" (quote ((let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "mypatch" (quote ((let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 95 398) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS 2" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 105 332) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REMOVE-IF" (quote remove-if) (quote ((om-load-inputfun (quote input-funbox) "PREDICATE" "PREDICATE" nil) (om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 107 281) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "HAS-NULL-VALUES" (quote has-null-values) (quote ((om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 73 217) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 119 165) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAP2?AND" (quote map2?and) (quote ((om-load-inputfun (quote input-funbox) "" "FN" nil) (om-load-inputfun (quote input-funbox) "" "LIST1" nil) (om-load-inputfun (quote input-funbox) "" "LIST2" nil))) (om-make-point 79 481) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is consonant 2" (quote ("elements" "paradigms" "myparadigm 3" "is consonant")) (quote ((om-load-inputfun (quote input-funbox) "" "x" nil) (om-load-inputfun (quote input-funbox) "" "y" nil))) (om-make-point 33 408) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FLATTEN-SEQC" (quote flatten-seqc) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 115 116) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 0 551) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (2 0 1 0 nil 0) (3 0 2 0 nil 0) (4 0 2 1 nil 0) (7 0 4 0 nil 0) (6 0 5 0 nil 0) (0 0 5 1 nil 0) (0 1 5 2 nil 0) (9 0 7 0 nil 0) (5 0 8 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 340)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 236 83) nil nil "l" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAP?AND" (quote map?and) (quote ((om-load-inputfun (quote input-funbox) "" "FN" nil) (om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 254 153) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "COMBINATIONS-OF2" (quote combinations-of2) (quote ((om-load-inputfun (quote input-funbox) "XS" "XS" nil))) (om-make-point 316 87) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 5 240) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((0 0 1 0 nil 0) (2 0 1 1 nil 0) (4 0 2 0 nil 0) (1 0 3 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 360)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 542 94) nil nil nil "consonant vertical intervals"))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((3 0 0 0 nil 0) (1 0 2 0 nil 0) (2 0 3 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 827 556)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 572 39) nil nil "l" "consonant vertical intervals - 1st species"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "no voice should make a leap greater than a 5th except with an ascending m6 - 1 input" (quote ("elements" "paradigms" "myparadigm 3" "no voice should make a leap greater than a 5th except with an ascending m6 - 1 input")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" nil))) (om-make-point 806 0) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "voice-overlap rule - 1-input" (quote ("elements" "paradigms" "myparadigm 3" "voice-overlap rule - 1-input")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" (list (list 60 62 64) (list 67 65 67) (list 70 69 67))))) (om-make-point 753 173) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "1to4-motion" (quote ("elements" "paradigms" "myparadigm 3" "voice-escmotion folder" "1to4-motion")) (quote ((om-load-inputfun (quote input-funbox) "" "input" (list (list 62 62 62 62 60) (list 62 64 65 67 69))))) (om-make-point 1282 191) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is 1to4" (quote ("elements" "paradigms" "myparadigm 3" "voice-escmotion folder" "is 1to4")) (quote ((om-load-inputfun (quote input-funbox) "" "input" (list (list 62 62 62 62 59) (list 66 67 64 66 67))))) (om-make-point 1240 191) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "voice-escmotion" (quote ("elements" "paradigms" "myparadigm 3" "voice-escmotion 3")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" nil) (om-load-inputfun (quote input-funbox) "" "select-motion-type fn" nil) (om-load-inputfun (quote input-funbox) "" "rule-definition fn" nil))) (om-make-point 1198 264) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is 1to2" (quote ("elements" "paradigms" "myparadigm 3" "voice-escmotion folder" "is 1to2")) (quote ((om-load-inputfun (quote input-funbox) "" "input" (list (list 62 62 60) (list 69 70 72))))) (om-make-point 1060 185) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "1to2-motion" (quote ("elements" "paradigms" "myparadigm 3" "voice-escmotion folder" "1to2-motion")) (quote ((om-load-inputfun (quote input-funbox) "" "input" (list (list (quote x1) (quote x1) (quote x1)) (list (quote y1) (quote y2) (quote y3)))))) (om-make-point 1102 185) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "voice-escmotion 3" (quote ("elements" "paradigms" "myparadigm 3" "voice-escmotion 3")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" nil) (om-load-inputfun (quote input-funbox) "" "select-motion-type fn" nil) (om-load-inputfun (quote input-funbox) "" "rule-definition fn" nil))) (om-make-point 1024 265) nil nil "l" "voice-escmotion 3" 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "tritones across voices" (quote ("elements" "paradigms" "myparadigm 3" "tritones across voices")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" (list 62 67 65 64 65 64 62)))) (om-make-point 357 282) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "similar motion into open intervals" (quote ("elements" "paradigms" "myparadigm 3" "similar motion into open intervals")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 93 91) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 2" 1 (om-make-point 244 190) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "modality" (quote ("elements" "paradigms" "myparadigm 3" "transposition")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" nil) (om-load-inputfun (quote input-funbox) "" "scale-pcset" nil))) (om-make-point 622/3 766/3) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "voice-overlap rule - 1-input" (quote ("elements" "paradigms" "myparadigm 3" "voice-overlap rule - 1-input")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" (list (list 60 62 64) (list 67 65 67) (list 70 69 67))))) (om-make-point 436 154) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "leaps to octaves" (quote ("elements" "paradigms" "myparadigm 3" "leaps to octaves 2")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 540 216) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "consecutive open intervals" (quote ("elements" "paradigms" "myparadigm 3" "consecutive open intervals 2")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" (list (list 60 62 64) (list 67 65 64) (list 72 72 72))))) (om-make-point 73 245) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "mypatch" (quote ((let ((box (om-load-boxcall (quote genfun) "?ALL<=" (quote ?all<=) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 328 131) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "HAS-NULL-VALUES" (quote has-null-values) (quote ((om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 387 22) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REMOVE-IF" (quote remove-if) (quote ((om-load-inputfun (quote input-funbox) "PREDICATE" "PREDICATE" nil) (om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 437 105) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 520 71) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAP?AND" (quote map?and) (quote ((om-load-inputfun (quote input-funbox) "" "FN" nil) (om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 361 199) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 348 300) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 50 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FLATTEN-SEQC" (quote flatten-seqc) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 501 23) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 2 0 nil 0) (3 0 2 1 nil 0) (7 0 3 0 nil 0) (0 0 4 0 nil 0) (2 0 4 1 nil 0) (4 0 5 0 nil 0) (6 0 7 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 751 435)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 3013/4 1399/4) nil nil "l" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 901 301) (om-make-point 32 28) 12 "12" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "voice-overlap and spacing" (quote ("elements" "paradigms" "myparadigm 3" "voice-overlap and spacing")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" (list (list 64 62 60) (list 72 71 72))) (om-load-inputfun (quote input-funbox) "" "max interval" 12))) (om-make-point 813 330) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "prepared cadence rule" (quote ("elements" "paradigms" "myparadigm 3" "prepared cadence rule 2")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 488 278) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "unison ending rule" (quote ("elements" "paradigms" "myparadigm 3" "unison ending rule 2")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 273 195) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 0 487) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "rule template" (quote ("elements" "paradigms" "myparadigm 3" "rule template")) (quote ((om-load-inputfun (quote input-funbox) "" "input" (list 55 (list 55 57) 58 60 nil)))) (om-make-point 30 208) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ASSERT!!" (quote assert!!) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 0 438) (om-make-point 979 47) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "tritone leaps" (quote ("elements" "paradigms" "myparadigm 3" "tritone leaps")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 346 136) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 0 75) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((5 0 6 1 nil 0) (4 0 6 2 nil 0) (7 0 9 1 nil 0) (8 0 9 2 nil 0) (12 0 13 1 nil 0) (18 0 19 1 nil 0) (24 0 22 0 nil 0) (26 0 24 0 nil 0) (23 0 24 1 nil 0) (13 0 24 2 nil 0) (21 0 24 3 nil 0) (11 0 24 4 nil 0) (16 0 24 5 nil 0) (25 0 24 8 nil 0) (17 0 24 10 nil 0) (14 0 24 11 nil 0) (20 0 24 12 nil 0) (10 0 24 13 nil 0) (15 0 24 14 nil 0) (1 0 24 16 nil 0) (0 0 24 17 nil 0) (2 0 24 20 nil 0) (6 0 24 21 nil 0))) nil 6.16))