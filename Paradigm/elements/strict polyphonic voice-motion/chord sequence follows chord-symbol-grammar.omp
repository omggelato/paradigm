; OM File Header - Saved 2022/12/21 5:19:43
; (6.16 :patc (om-make-point 24 24) (om-make-point 50 50) (om-make-point 500 434) "" 908 0 nil "2022/12/20 23:28:14")
; End File Header
; External resources 
; (list (list (quote :abstraction) "#P\"C:../../misc/triad1.omp\""))
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "chord sequence follows chord-symbol-grammar" (quote ((let ((box (let ((newbox (om-load-boxcall (quote genfun) "MAP-ORV" (quote t2l::map-orv) (quote ((om-load-inputfun (quote input-funbox) "" "FN" nil) (om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 121 314) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 121 314)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 28 37) (om-make-point 32 28) 12 "12" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "LIST%V" (quote t2l::list%v) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "VALUE" nil))) (om-make-point 6 67) nil nil "l" nil 1))) (setf (frame-position newbox) (om-make-point 6 67)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR 3" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 25 119) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "EQUALP" (quote equalp) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil) (om-load-inputfun (quote input-funbox) "Y" "Y" nil))) (om-make-point 213 324) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REMOVE-DUPLICATES 2" (quote remove-duplicates) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 398 201) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REMOVE-DUPLICATES" (quote remove-duplicates) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil) (om-load-inputkeyword (quote input-keyword) "" "test" (quote :test) nil nil))) (om-make-point 153 372) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR 2" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 242 427) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 259 356) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 257 301) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 60 372) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord-symbol-grammar" 1 (om-make-point 832/3 18) "" "chord-symbol-grammar" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord list" 0 (om-make-point 59 21) "" "chord list" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "chord-sequence vs chord-symbols-list" (om-load-patch-abs1 "chord-sequence vs chord-symbols-list" (quote ((let ((box (let ((newbox (om-load-boxcall (quote genfun) "MAP2ANDV" (quote t2l::map2andv) (quote ((om-load-inputfun (quote input-funbox) "" "FN" nil) (om-load-inputfun (quote input-funbox) "" "LIST1" nil) (om-load-inputfun (quote input-funbox) "" "LIST2" nil))) (om-make-point 146 204) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 146 204)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "ALL-MEMBERV" (quote t2l::all-memberv) (quote ((om-load-inputfun (quote input-funbox) "" "LIST" nil) (om-load-inputfun (quote input-funbox) "" "SEQUENCE" nil))) (om-make-point 46 139) nil nil "l" nil 1))) (setf (frame-position newbox) (om-make-point 46 139)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord-symbols-list" 1 (om-make-point 206 125) "" "chord-symbols-list" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 40 265) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord-sequence" 0 (om-make-point 115 125) "" "chord-sequence" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (4 0 0 1 nil 0) (2 0 0 2 nil 0) (0 0 3 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 280)) (quote ((om-load-inputfun (quote input-funbox) "" "chord" nil) (om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 10 227) nil (list nil) "l" "chord-sequence vs chord-symbols-list"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "chord-symbols2pcsets" (om-load-lisp-abspatch "chord-symbols2pcsets" 6.16 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (symbols)$  (let ((map$         '((i (0 4 7) 0)$           (ii (0 3 7) 2)$           (iii (0 3 7) 4)$           (iv (0 4 7) 5)$           (v (0 4 7) 7)$           (vi (0 3 7) 9)$           (vii (0 3 6) 11)$           (v/v (2 6 9) 0)$           (n (5 8 1) 0))))$    (labels ((symbol2pcset (symbol)$               (let ((symbol-data (cdr (assoc symbol map))))$                 (mapcar #'(lambda (x) (mod x 12)) (om+ (car symbol-data) (cadr symbol-data))))))$      (mapcar #'symbol2pcset symbols))))") (quote ((om-load-inputfun (quote input-funbox) "" "SYMBOLS" nil))) (om-make-point 185 226) nil (list nil) "l" "chord-symbols2pcsets"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "possible sequences of triads and applied chords" (om-load-patch-abs1 "possible sequences of triads and applied chords" (quote ((let ((box (let ((newbox (om-load-boxcall (quote genfun) "FIND-ALL" (quote t2l::find-all) (quote ((om-load-inputfun (quote input-funbox) "" "I" nil) (om-load-inputfun (quote input-funbox) "" "FORM1" nil))) (om-make-point 164 361) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 164 361)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 20 434) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "symbol-grammar" 1 (om-make-point 198 227) "" "symbol-grammar" (list (list (quote :s) (quote :i) (quote :v) (quote :i)) (list (quote :i) (quote i)) (list (quote :iv) (quote iv)) (list (quote :v) (quote v)) (list (quote :v) (quote :iv) (quote v))) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord-list" 0 (om-make-point 526/3 178) "" "chord-list" (list (list 48 48 48 54) (list 48 49 48 63) (list 48 50 48 64) (list 48 51 48 72)) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "cfg" (om-load-patch-abs1 "cfg" (quote ((let ((box (let ((newbox (om-load-boxcall (quote genfun) "ASSERT!!" (quote t2l::assert!!) (quote ((om-load-inputfun (quote input-funbox) "" "SEQUENCE" nil) (om-load-inputfun (quote input-funbox) "" "SEQUENCE" nil))) (om-make-point 226 221) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 226 221)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "symbol-grammar" 1 (om-make-point 206 45) "" "symbol-grammar" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 162 297) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil (list (quote _) (quote _) (quote _)) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "MAPPRULES" (quote t2l::mapprules) (quote ((om-load-inputfun (quote input-funbox) "" "INPUT" nil) (om-load-inputfun (quote input-funbox) "" "PRULES" nil) (om-load-inputkeyword (quote input-keyword) "" "symbol-mode" (quote :symbol-mode) nil nil))) (om-make-point 186 174) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 186 174)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "MAKE-SCREAMER-VARIABLES" (quote t2l::make-screamer-variables) (quote ((om-load-inputfun (quote input-funbox) "" "LIST" (list (quote t2l::_) (quote t2l::_) (quote t2l::_) (quote t2l::_))) (om-load-inputkeyword (quote input-keyword) "" "symbol-mode" (quote :symbol-mode) nil nil))) (om-make-point 66 107) nil nil "&" nil 1))) (setf (frame-position newbox) (om-make-point 66 107)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 227 144) (om-make-point 24 28) (quote t) "t" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 152 77) (om-make-point 24 28) (quote t) "t" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((4 0 0 0 nil 0) (5 0 0 1 nil 0) (0 0 2 0 nil 0) (5 0 4 0 nil 0) (1 0 4 1 nil 0) (6 0 4 2 nil 0) (3 0 5 0 nil 0) (7 0 5 1 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 797/4 2339/8) nil (list (list nil nil nil nil)) nil "cfg"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 148 244) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "_" (om-load-lisp-abspatch "_" 6.16 ";;; Edit a valid LAMBDA EXPRESSION for \"_\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (x) '_)") (quote ((om-load-inputfun (quote input-funbox) "" "X" nil))) (om-make-point 113 170) nil (list nil) "l" "_"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "MAP2ANDV" (quote t2l::map2andv) (quote ((om-load-inputfun (quote input-funbox) "" "FN" nil) (om-load-inputfun (quote input-funbox) "" "LIST1" nil) (om-load-inputfun (quote input-funbox) "" "LIST2" nil))) (om-make-point 477 305) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 477 305)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "mypatch" (quote ((let ((box (let ((newbox (om-load-boxcall (quote genfun) "MAP3ORV" (quote t2l::map3orv) (quote ((om-load-inputfun (quote input-funbox) "" "FN" nil) (om-load-inputfun (quote input-funbox) "" "LIST1" nil) (om-load-inputfun (quote input-funbox) "" "LIST2" nil) (om-load-inputfun (quote input-funbox) "" "LIST3" nil))) (om-make-point 170 214) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 170 214)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "mypatch 3" (quote ((let ((box (om-load-boxcall (quote patch-box) "triad1" (quote ("elements" "misc" "triad1")) (quote ((om-load-inputfun (quote input-funbox) "" "chord" nil) (om-load-inputfun (quote input-funbox) "" "chord-symbol-variable" nil) (om-load-inputfun (quote input-funbox) "" "symbol" nil) (om-load-inputfun (quote input-funbox) "" "chord-pcs" nil) (om-load-inputfun (quote input-funbox) "" "transposition" 0))) (om-make-point 197 155) nil nil nil "triad1" 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord-symbol-variable" 4 (om-make-point 295 45) "" "chord-symbol-variable" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord-variables" 3 (om-make-point 205 45) "" "chord-variables" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 5 240) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "transposition" 2 (om-make-point 125 45) "" "transposition" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "pcset" 1 (om-make-point 85 45) "" "pcset" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord-symbol" 0 (om-make-point 5 45) "" "chord-symbol" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "triad 1" (om-load-patch-abs1 "triad 1" (quote ((let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 337 279) (om-make-point 68 28) (quote chord-pcs) "chord-pcs" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "ALERT2" (quote t2l::alert2) (quote ((om-load-inputfun (quote input-funbox) "" "INPUT" nil) (om-load-inputkeyword (quote input-keyword) "" "label" (quote :label) nil nil))) (om-make-point 317 309) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 317 309)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "transposition" 4 (om-make-point 365 69) "" "transposition" 0 nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 114 543) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord-pcs" 3 (om-make-point 767/3 70) "" "chord-pcs" (list 0 4 7) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "symbol" 2 (om-make-point 623/3 70) "" "symbol" (quote i) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord-symbol-variable" 1 (om-make-point 260/3 70) "" "chord-symbol-variable" (quote i) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord" 0 (om-make-point 50 70) "" "chord" (list 60 64 67) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "OMANDV" (quote t2l::omandv) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 719/3 480) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 719/3 480)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "ALL-MEMBERV" (quote t2l::all-memberv) (quote ((om-load-inputfun (quote input-funbox) "" "LIST" nil) (om-load-inputfun (quote input-funbox) "" "SEQUENCE" nil))) (om-make-point 410/3 230) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 410/3 230)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "EQUALV" (quote screamer:equalv) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil) (om-load-inputfun (quote input-funbox) "Y" "Y" nil))) (om-make-point 476/3 156) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 6" (quote t) (quote nil) (om-make-point 269/3 141) (om-make-point 32 28) 12 "12" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "LIST%V" (quote t2l::list%v) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "VALUE" nil))) (om-make-point 203/3 171) nil nil "&" nil 1))) (setf (frame-position newbox) (om-make-point 203/3 171)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 920/3 250) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 5" (quote t) (quote nil) (om-make-point 917/3 168) (om-make-point 32 28) 12 "12" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MOD" (quote mod) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil) (om-load-inputfun (quote input-funbox) "Y" "Y" nil))) (om-make-point 869/3 198) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM+" (quote om+) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 1052/3 151) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((13 0 1 0 nil 0) (0 0 1 1 nil 0) (8 0 3 0 nil 0) (10 0 8 0 nil 0) (9 0 8 1 nil 0) (12 0 9 0 nil 0) (1 0 9 1 nil 0) (6 0 10 0 nil 0) (5 0 10 1 nil 0) (7 0 12 0 nil 0) (11 0 12 1 nil 0) (15 0 13 0 nil 0) (16 0 13 1 nil 0) (14 0 15 1 nil 0) (4 0 16 0 nil 0) (2 0 16 1 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "chord" nil) (om-load-inputfun (quote input-funbox) "" "chord-symbol-variable" nil) (om-load-inputfun (quote input-funbox) "" "symbol" nil) (om-load-inputfun (quote input-funbox) "" "chord-pcs" nil) (om-load-inputfun (quote input-funbox) "" "transposition" 0))) (om-make-point 77 135) nil (list nil) nil "triad 1"))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((7 0 3 0 nil 0) (2 0 7 0 nil 0) (1 0 7 1 nil 0) (6 0 7 2 nil 0) (5 0 7 3 nil 0) (4 0 7 4 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "chord-symbol" nil) (om-load-inputfun (quote input-funbox) "" "pcset" nil) (om-load-inputfun (quote input-funbox) "" "transposition" nil) (om-load-inputfun (quote input-funbox) "" "chord-variables" nil) (om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 90 1764/13) nil (list nil) "l" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 170 146) nil nil nil nil 3))) (setf (numouts box) 3) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "chord-symbols2pcsets" (om-load-lisp-abspatch "chord-symbols2pcsets" 6.16 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (symbols)$  (let ((map$         '((i (0 4 7) 0)$           (ii (0 3 7) 2)$           (iii (0 3 7) 4)$           (iv (0 4 7) 5)$           (v (0 4 7) 7)$           (vi (0 3 7) 9)$           (vii (0 3 6) 11)$           (n (5 8 1) 0))))$    (labels ((symbol2pcset (symbol)$               (let ((symbol-data (cdr (assoc symbol map))))$                 (om+ (car symbol-data) (cadr symbol-data))))))))") (quote ((om-load-inputfun (quote input-funbox) "" "SYMBOLS" nil))) (om-make-point 218 73) nil (list (list (list 0 4 7) 0)) nil "chord-symbols2pcsets"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord-symbol" 1 (om-make-point 125 45) "" "chord-symbol" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 105 309) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord" 0 (om-make-point 75 45) "" "chord" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (2 0 0 1 nil 0) (2 1 0 2 nil 0) (2 2 0 3 nil 0) (6 0 1 3 nil 0) (4 0 1 4 nil 0) (3 0 2 0 nil 0) (0 0 5 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 442 237) nil (list nil) "l" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((4 0 0 1 nil 0) (0 0 1 0 nil 0) (5 0 4 0 nil 0) (2 0 4 1 nil 0) (6 0 5 0 nil 0) (3 0 5 1 nil 0) (8 0 7 0 nil 0))) 6.16 nil "" (om-make-point 200 70) (om-make-point 500 350)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 124 12613/144) nil (list (list (list (quote i) (quote iv) (quote v) (quote i)) (list (quote i) (quote n) (quote v) (quote i)) (list (quote i) (quote v/v) (quote v) (quote i)))) nil "possible sequences of triads and applied chords"))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((13 0 0 0 nil 0) (9 0 0 1 nil 0) (1 0 2 1 nil 0) (2 0 3 0 nil 0) (12 0 3 1 nil 0) (4 0 6 1 nil 0) (6 0 7 0 nil 0) (8 0 7 1 nil 0) (9 0 8 0 nil 0) (14 0 9 0 nil 0) (15 0 9 1 nil 0) (0 0 10 0 nil 0) (3 0 13 0 nil 0) (12 0 15 0 nil 0) (11 0 15 1 nil 0))) nil 6.16))
