; OM File Header - Saved 2023/10/26 15:18:01
; (6.16 :patc (om-make-point 66.0 10) (om-make-point 352 0) (om-make-point 978 401) "" 908 0 "2022/12/25 02:25:35" "2023/10/26 15:11:12")
; End File Header
; External resources 
; (list (list (quote :abstraction) "#P\"C:leaps to octaves 2.omp\"" "#P\"C:is a step.omp\"" "#P\"C:is consonant.omp\"" "#P\"C:is dissonant.omp\"" "#P\"C:is a step or a repeat.omp\"" "#P\"C:voice-escmotion folder/print inputs to voice-escmotion.omp\"" "#P\"C:voice-escmotion folder/is 1to2.omp\"" "#P\"C:voice-escmotion 3.omp\"" "#P\"C:tritones across voices.omp\"" "#P\"C:similar motion into open intervals.omp\"" "#P\"C:transposition.omp\"" "#P\"C:voice-overlap rule - 1-input.omp\"" "#P\"C:consecutive open intervals 2.omp\"" "#P\"C:prepared cadence rule 2.omp\"" "#P\"C:unison ending rule 2.omp\"" "#P\"C:repeated notes in voice2  ii.omp\"" "#P\"C:rule template.omp\"" "#P\"C:tritone leaps.omp\"" "#P\"C:no voice should make a leap greater than a 5th except with an ascending m6 - 1 input.omp\""))
(in-package :om)(load-lib-for (quote ("myextension")))(setf *om-current-persistent* (om-load-patch1 "rules for strict 2-to-1 motion ex" (quote ((let ((box (om-load-boxcall (quote patch-box) "leaps to octaves 2" (quote ("elements" "paradigms" "myparadigm 3" "leaps to octaves 2")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 814 385/2) nil nil "l" "leaps to octaves" 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "1to2-motion 2" (om-load-patch-abs1 "1to2-motion" (quote ((let ((box (om-load-boxcall (quote genfun) "HAS-NULL-VALUES" (quote has-null-values) (quote ((om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 39 170) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 143 340) (om-make-point 24 28) (quote t) "t" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 123 370) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NOT" (quote not) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 52 282) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch 2" (om-load-patch-abs1 "mypatch 2" (quote ((let ((box (om-load-boxcall (quote genfun) "?ALL>" (quote ?all>) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 672 204) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?ALL<" (quote ?all<) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 613 204) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ANDV 3" (quote screamer:andv) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 693 337) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is a step 2" (quote ("elements" "paradigms" "myparadigm 3" "is a step")) (quote ((om-load-inputfun (quote input-funbox) "" "x1" nil) (om-load-inputfun (quote input-funbox) "" "x2" nil))) (om-make-point 842 255) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is a step" (quote ("elements" "paradigms" "myparadigm 3" "is a step")) (quote ((om-load-inputfun (quote input-funbox) "" "x1" nil) (om-load-inputfun (quote input-funbox) "" "x2" nil))) (om-make-point 792 255) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS 9" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 806 192) nil nil nil nil 3))) (setf (numouts box) 3) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS 8" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 755 125) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ORV 2" (quote screamer:orv) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 653 262) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS 7" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 595 125) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ANDV 2" (quote screamer:andv) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 72 395) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is consonant 2" (quote ("elements" "paradigms" "myparadigm 3" "is consonant")) (quote ((om-load-inputfun (quote input-funbox) "" "x" nil) (om-load-inputfun (quote input-funbox) "" "y" nil))) (om-make-point 104 266) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is consonant" (quote ("elements" "paradigms" "myparadigm 3" "is consonant")) (quote ((om-load-inputfun (quote input-funbox) "" "x" nil) (om-load-inputfun (quote input-funbox) "" "y" nil))) (om-make-point 24 256) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS 6" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 86 192) nil nil nil nil 3))) (setf (numouts box) 3) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS 5" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 6 192) nil nil nil nil 3))) (setf (numouts box) 3) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS 4" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 35 125) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 50 456) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 102 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ANDV" (quote screamer:andv) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 377 347) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ORV" (quote screamer:orv) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 212 400) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NOTV" (quote screamer:notv) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 276 347) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is dissonant" (quote ("elements" "paradigms" "myparadigm 3" "is dissonant")) (quote ((om-load-inputfun (quote input-funbox) "" "x" nil) (om-load-inputfun (quote input-funbox) "" "y" nil))) (om-make-point 249 267) nil nil "&" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 235 125) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS 2" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 206 192) nil nil nil nil 3))) (setf (numouts box) 3) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS 3" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 286 192) nil nil nil nil 3))) (setf (numouts box) 3) box))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((8 1 0 0 nil 0) (8 1 1 0 nil 0) (7 0 2 0 nil 0) (4 0 2 1 nil 0) (3 0 2 2 nil 0) (5 1 3 0 nil 0) (5 2 3 1 nil 0) (5 0 4 0 nil 0) (5 1 4 1 nil 0) (6 1 5 0 nil 0) (16 0 6 0 nil 0) (1 0 7 0 nil 0) (0 0 7 1 nil 0) (16 0 8 0 nil 0) (11 0 9 0 nil 0) (10 0 9 1 nil 0) (18 0 9 2 nil 0) (13 2 10 0 nil 0) (12 2 10 1 nil 0) (13 0 11 0 nil 0) (12 0 11 1 nil 0) (14 1 12 0 nil 0) (14 0 13 0 nil 0) (16 0 14 0 nil 0) (9 0 15 0 nil 0) (20 0 17 0 nil 0) (2 0 17 1 nil 0) (19 0 18 0 nil 0) (17 0 18 1 nil 0) (20 0 19 0 nil 0) (22 1 20 0 nil 0) (23 1 20 1 nil 0) (16 0 21 0 nil 0) (21 0 22 0 nil 0) (21 1 23 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 118 1072/7) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "mypatch" (quote ((let ((box (om-load-boxcall (quote patch-box) "is dissonant" (quote ("elements" "paradigms" "myparadigm 3" "is dissonant")) (quote ((om-load-inputfun (quote input-funbox) "" "x" nil) (om-load-inputfun (quote input-funbox) "" "y" nil))) (om-make-point 460 140) nil nil "&" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 168 339) (om-make-point 24 28) (quote t) "t" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 156 369) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "HAS-NULL-VALUES 3" (quote t2l::has-null-values) (quote ((om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 179 194) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 179 194)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST 3" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 193 142) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "HAS-NULL-VALUES 2" (quote t2l::has-null-values) (quote ((om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 92 194) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 92 194)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST 2" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 123 142) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 33 142) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "HAS-NULL-VALUES" (quote t2l::has-null-values) (quote ((om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 2 194) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 2 194)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "active voice1" (om-load-patch-abs1 "active voice1" (quote ((let ((box (om-load-boxin "x2 and y2 are dissonant" 6 (om-make-point 302 242) "" "x2 and y2 are dissonant" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ORV 2" (quote screamer:orv) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 241 361) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NOTV" (quote screamer:notv) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 254 318) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 161 429) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "y3" 5 (om-make-point 255 0) "" "y3" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "y2" 4 (om-make-point 223 0) "" "y2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "y1" 3 (om-make-point 190 0) "" "y1" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "x3" 2 (om-make-point 155 10) "" "x3" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "x2" 1 (om-make-point 124 10) "" "x2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "x1" 0 (om-make-point 90 10) "" "x1" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ANDV 4" (quote screamer:andv) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 204 615/2) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "OM<=V 3" (quote t2l::om<=v) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 292 307/2) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 292 307/2)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "OM>=V 2" (quote t2l::om>=v) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 182 307/2) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 182 307/2)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ANDV" (quote screamer:andv) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 270 417/2) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ORV" (quote screamer:orv) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 217 519/2) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ANDV 2" (quote screamer:andv) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 160 417/2) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "OM>V" (quote t2l::om>v) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 244 307/2) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 244 307/2)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "OM<V" (quote t2l::om<v) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 137 307/2) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 137 307/2)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is a step or a repeat 3" (quote ("elements" "paradigms" "myparadigm 3" "is a step or a repeat")) (quote ((om-load-inputfun (quote input-funbox) "" "x1" nil) (om-load-inputfun (quote input-funbox) "" "x2" nil))) (om-make-point 450 307/2) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is a step 3" (quote ("elements" "paradigms" "myparadigm 3" "is a step")) (quote ((om-load-inputfun (quote input-funbox) "" "x1" nil) (om-load-inputfun (quote input-funbox) "" "x2" nil))) (om-make-point 91 307/2) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is a step 4" (quote ("elements" "paradigms" "myparadigm 3" "is a step")) (quote ((om-load-inputfun (quote input-funbox) "" "x1" nil) (om-load-inputfun (quote input-funbox) "" "x2" nil))) (om-make-point 41 307/2) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is a step or a repeat 4" (quote ("elements" "paradigms" "myparadigm 3" "is a step or a repeat")) (quote ((om-load-inputfun (quote input-funbox) "" "x1" nil) (om-load-inputfun (quote input-funbox) "" "x2" nil))) (om-make-point 340 307/2) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment 2" (om-make-point 100 60) (quote "voice1 active, voice2 passive") "" (om-make-point 161 82) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((10 0 1 0 nil 0) (2 0 1 1 nil 0) (0 0 2 0 nil 0) (1 0 3 0 nil 0) (20 0 10 0 nil 0) (19 0 10 1 nil 0) (14 0 10 2 nil 0) (21 0 10 3 nil 0) (18 0 10 4 nil 0) (0 0 10 5 nil 0) (6 0 11 0 nil 0) (5 0 11 1 nil 0) (4 0 11 2 nil 0) (6 0 12 0 nil 0) (5 0 12 1 nil 0) (4 0 12 2 nil 0) (16 0 13 0 nil 0) (11 0 13 1 nil 0) (15 0 14 0 nil 0) (13 0 14 1 nil 0) (17 0 15 0 nil 0) (12 0 15 1 nil 0) (9 0 16 0 nil 0) (8 0 16 1 nil 0) (7 0 16 2 nil 0) (9 0 17 0 nil 0) (8 0 17 1 nil 0) (7 0 17 2 nil 0) (5 0 18 0 nil 0) (4 0 18 1 nil 0) (8 0 19 0 nil 0) (7 0 19 1 nil 0) (9 0 20 0 nil 0) (8 0 20 1 nil 0) (6 0 21 0 nil 0) (5 0 21 1 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "x1" nil) (om-load-inputfun (quote input-funbox) "" "x2" nil) (om-load-inputfun (quote input-funbox) "" "x3" nil) (om-load-inputfun (quote input-funbox) "" "y1" nil) (om-load-inputfun (quote input-funbox) "" "y2" nil) (om-load-inputfun (quote input-funbox) "" "y3" nil) (om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 7144/13 2918/13) nil nil nil "active voice1"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "active voice2" (om-load-patch-abs1 "active voice2" (quote ((let ((box (om-load-boxin "x2 and y2 are dissonant" 6 (om-make-point 555 235) "" "x2 and y2 are dissonant" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NOTV" (quote screamer:notv) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 384 366) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ORV" (quote screamer:orv) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 371 409) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 4962/13 460) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "y3" 5 (om-make-point 7185/13 40) "" "y3" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "y2" 4 (om-make-point 6769/13 40) "" "y2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "y1" 3 (om-make-point 6340/13 40) "" "y1" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "x3" 2 (om-make-point 5365/13 50) "" "x3" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "x2" 1 (om-make-point 4962/13 50) "" "x2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "x1" 0 (om-make-point 4520/13 50) "" "x1" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ANDV 3" (quote screamer:andv) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 334 356) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is a step or a repeat 2" (quote ("elements" "paradigms" "myparadigm 3" "is a step or a repeat")) (quote ((om-load-inputfun (quote input-funbox) "" "x1" nil) (om-load-inputfun (quote input-funbox) "" "x2" nil))) (om-make-point 50 202) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is a step 2" (quote ("elements" "paradigms" "myparadigm 3" "is a step")) (quote ((om-load-inputfun (quote input-funbox) "" "x1" nil) (om-load-inputfun (quote input-funbox) "" "x2" nil))) (om-make-point 451 202) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is a step" (quote ("elements" "paradigms" "myparadigm 3" "is a step")) (quote ((om-load-inputfun (quote input-funbox) "" "x1" nil) (om-load-inputfun (quote input-funbox) "" "x2" nil))) (om-make-point 501 202) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is a step or a repeat" (quote ("elements" "paradigms" "myparadigm 3" "is a step or a repeat")) (quote ((om-load-inputfun (quote input-funbox) "" "x1" nil) (om-load-inputfun (quote input-funbox) "" "x2" nil))) (om-make-point 160 202) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "OM<=V 2" (quote t2l::om<=v) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 262 202) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 262 202)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "OM>=V" (quote t2l::om>=v) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 372 202) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 372 202)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ANDV 6" (quote screamer:andv) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 400 257) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ORV 2" (quote screamer:orv) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 347 308) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ANDV 5" (quote screamer:andv) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 290 257) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "OM>V 2" (quote t2l::om>v) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 314 202) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 314 202)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "OM<V 2" (quote t2l::om<v) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 427 202) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 427 202)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 100 60) (quote "voice2 active, voice1 passive") "" (om-make-point 223 131) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((0 0 1 0 nil 0) (10 0 2 0 nil 0) (1 0 2 1 nil 0) (2 0 3 0 nil 0) (11 0 10 0 nil 0) (14 0 10 1 nil 0) (18 0 10 2 nil 0) (12 0 10 3 nil 0) (13 0 10 4 nil 0) (0 0 10 5 nil 0) (9 0 11 0 nil 0) (8 0 11 1 nil 0) (6 0 12 0 nil 0) (5 0 12 1 nil 0) (5 0 13 0 nil 0) (4 0 13 1 nil 0) (8 0 14 0 nil 0) (7 0 14 1 nil 0) (9 0 15 0 nil 0) (8 0 15 1 nil 0) (7 0 15 2 nil 0) (9 0 16 0 nil 0) (8 0 16 1 nil 0) (7 0 16 2 nil 0) (16 0 17 0 nil 0) (21 0 17 1 nil 0) (19 0 18 0 nil 0) (17 0 18 1 nil 0) (15 0 19 0 nil 0) (20 0 19 1 nil 0) (6 0 20 0 nil 0) (5 0 20 1 nil 0) (4 0 20 2 nil 0) (6 0 21 0 nil 0) (5 0 21 1 nil 0) (4 0 21 2 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "x1" nil) (om-load-inputfun (quote input-funbox) "" "x2" nil) (om-load-inputfun (quote input-funbox) "" "x3" nil) (om-load-inputfun (quote input-funbox) "" "y1" nil) (om-load-inputfun (quote input-funbox) "" "y2" nil) (om-load-inputfun (quote input-funbox) "" "y3" nil) (om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 3316/13 225) nil nil nil "active voice2"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ORV 4" (quote screamer:orv) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 271 319) (om-make-point 203 42) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 119 438) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "y3" 5 (om-make-point 420 50) "" "y3" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "y2" 4 (om-make-point 388 50) "" "y2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "y1" 3 (om-make-point 355 50) "" "y1" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "x3" 2 (om-make-point 280 50) "" "x3" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "x2" 1 (om-make-point 249 50) "" "x2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "x1" 0 (om-make-point 215 50) "" "x1" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((17 0 0 0 nil 0) (14 0 0 1 nil 0) (3 0 2 0 nil 0) (1 0 2 1 nil 0) (11 0 2 2 nil 0) (4 0 3 0 nil 0) (18 0 4 0 nil 0) (17 0 4 1 nil 0) (16 0 4 2 nil 0) (15 0 4 3 nil 0) (14 0 4 4 nil 0) (13 0 4 5 nil 0) (6 0 5 0 nil 0) (16 0 6 0 nil 0) (13 0 6 1 nil 0) (17 0 7 0 nil 0) (14 0 7 1 nil 0) (7 0 8 0 nil 0) (18 0 9 0 nil 0) (17 0 9 1 nil 0) (16 0 9 2 nil 0) (15 0 9 3 nil 0) (14 0 9 4 nil 0) (13 0 9 5 nil 0) (0 0 9 6 nil 0) (18 0 10 0 nil 0) (17 0 10 1 nil 0) (16 0 10 2 nil 0) (15 0 10 3 nil 0) (14 0 10 4 nil 0) (13 0 10 5 nil 0) (0 0 10 6 nil 0) (10 0 11 0 nil 0) (9 0 11 1 nil 0) (2 0 12 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "x1" nil) (om-load-inputfun (quote input-funbox) "" "x2" nil) (om-load-inputfun (quote input-funbox) "" "x3" nil) (om-load-inputfun (quote input-funbox) "" "x4" nil) (om-load-inputfun (quote input-funbox) "" "y1" nil) (om-load-inputfun (quote input-funbox) "" "y2" nil))) (om-make-point 300 134) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 154 50) (quote "((x1 y1) (x2 y2) ...)") "" (om-make-point 75 11) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 18 462) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 11 49) "" nil (list (list (quote x1) (quote x1) (quote x1)) (list (quote y1) (quote y2) (quote y3))) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((8 0 0 0 nil 0) (3 0 2 0 nil 0) (4 0 2 1 nil 0) (1 0 2 2 nil 0) (0 0 3 0 nil 0) (8 0 4 0 nil 0) (2 0 7 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 396 172)) (quote ((om-load-inputfun (quote input-funbox) "" "input" (list (list (quote x1) (quote x1) (quote x1)) (list (quote y1) (quote y2) (quote y3)))))) (om-make-point 1102 55) nil nil "l" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "print inputs to voice-escmotion" (quote ("elements" "paradigms" "myparadigm 3" "voice-escmotion folder" "print inputs to voice-escmotion")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" nil))) (om-make-point 1020 215) nil nil "l" "print inputs to voice-escmotion" 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is 1to2" (quote ("elements" "paradigms" "myparadigm 3" "voice-escmotion folder" "is 1to2")) (quote ((om-load-inputfun (quote input-funbox) "" "input" (list (list 62 62 60) (list 69 70 72))))) (om-make-point 1060 55) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "voice-escmotion 3" (quote ("elements" "paradigms" "myparadigm 3" "voice-escmotion 3")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" nil) (om-load-inputfun (quote input-funbox) "" "select-motion-type fn" nil) (om-load-inputfun (quote input-funbox) "" "rule-definition fn" nil))) (om-make-point 1024 135) nil nil "l" "voice-escmotion 3" 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "tritones across voices" (quote ("elements" "paradigms" "myparadigm 3" "tritones across voices")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" (list 62 67 65 64 65 64 62)))) (om-make-point 587 371) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "similar motion into open intervals" (quote ("elements" "paradigms" "myparadigm 3" "similar motion into open intervals")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 215 58) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 2" 1 (om-make-point 139 44) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "modality" (quote ("elements" "paradigms" "myparadigm 3" "transposition")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" nil) (om-load-inputfun (quote input-funbox) "" "scale-pcset" nil))) (om-make-point 10 496/3) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "voice-overlap rule - 1-input - 1st species" (om-load-patch-abs1 "voice-overlap rule - 1-input - 1st species" (quote ((let ((box (om-load-boxcall (quote patch-box) "voice-overlap rule - 1-input" (quote ("elements" "paradigms" "myparadigm 3" "voice-overlap rule - 1-input")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" (list (list 60 62 64) (list 67 65 67) (list 70 69 67))))) (om-make-point 106 216) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "as 1st species" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" nil))) (om-make-point 81 130) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS 3" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 24 127) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS 2" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 293 444) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CAR" (quote car) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 276 315) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REMOVE-IF" (quote remove-if) (quote ((om-load-inputfun (quote input-funbox) "PREDICATE" "PREDICATE" nil) (om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 278 249) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NULL" (quote null) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 248 155) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "SOME" (quote some) (quote ((om-load-inputfun (quote input-funbox) "PREDICATE" "PREDICATE" nil) (om-load-inputfun (quote input-funbox) "FIRST-SEQUENCE" "FIRST-SEQUENCE" nil))) (om-make-point 262 202) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 306 186) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FLATTEN-SEQC" (quote t2l::flatten-seqc) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 302 141) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 255 379) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 12 205) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "sequence" 0 (om-make-point 5 40) "" "sequence" (list (list 60 67 60 59) (list 72 71 72 74) (list 76 74 76 74)) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 300 510) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 200 510) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((10 0 0 0 nil 0) (8 1 1 0 nil 0) (3 0 2 0 nil 0) (5 0 3 0 nil 0) (6 0 3 1 nil 0) (4 0 5 0 nil 0) (7 0 6 0 nil 0) (9 0 7 0 nil 0) (2 0 8 0 nil 0) (0 0 9 0 nil 0) (1 0 11 0 nil 0) (8 0 12 0 nil 0))) 1 "as 1st species" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 43 389) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "sequence" 0 (om-make-point 5 45) "" "sequence" (list (list 60 62 64) (list 67 65 67) (list 70 69 67)) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (3 0 1 0 nil 0) (0 0 2 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 675 469)) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" (list (list 60 62 64) (list 67 65 67) (list 70 69 67))))) (om-make-point 740 0) nil nil "l" "voice-overlap rule - 1-input - 1st species"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "voice-overlap rule - 1-input" (quote ("elements" "paradigms" "myparadigm 3" "voice-overlap rule - 1-input")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" (list (list 60 62 64) (list 67 65 67) (list 70 69 67))))) (om-make-point 436 24) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "leaps to octaves" (quote ("elements" "paradigms" "myparadigm 3" "leaps to octaves 2")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 540 86) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "consecutive open intervals" (quote ("elements" "paradigms" "myparadigm 3" "consecutive open intervals 2")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" (list (list 60 62 64) (list 67 65 64) (list 72 72 72))))) (om-make-point 73 115) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "prepared cadence rule" (quote ("elements" "paradigms" "myparadigm 3" "prepared cadence rule 2")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 140 232) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "unison ending rule" (quote ("elements" "paradigms" "myparadigm 3" "unison ending rule 2")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 73 205) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "repeated notes in voice2  ii" (quote ("elements" "paradigms" "myparadigm 3" "repeated notes in voice2  ii")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 393 161/2) nil nil "l" "repeated notes in voice2  ii" 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 0 407) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "rule template" (quote ("elements" "paradigms" "myparadigm 3" "rule template")) (quote ((om-load-inputfun (quote input-funbox) "" "input" (list 55 (list 55 57) 58 60 nil)))) (om-make-point 0 228) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ASSERT!!" (quote assert!!) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 0 308) (om-make-point 701 47) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "tritone leaps" (quote ("elements" "paradigms" "myparadigm 3" "tritone leaps")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 346 6) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "no voice should make a leap greater than a 5th except with an ascending m6 - 1 input" (quote ("elements" "paradigms" "myparadigm 3" "no voice should make a leap greater than a 5th except with an ascending m6 - 1 input")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" nil))) (om-make-point 322 158) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 0 40) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((3 0 4 1 nil 0) (1 0 4 2 nil 0) (7 0 8 1 nil 0) (18 0 16 0 nil 0) (21 0 18 0 nil 0) (17 0 18 1 nil 0) (8 0 18 2 nil 0) (14 0 18 3 nil 0) (13 0 18 4 nil 0) (19 0 18 13 nil 0) (0 0 18 16 nil 0))) nil 6.16))
