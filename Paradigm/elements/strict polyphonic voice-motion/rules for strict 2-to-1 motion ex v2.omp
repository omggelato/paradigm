; OM File Header - Saved 2023/10/27 23:11:18
; (6.16 :patc (om-make-point 66.0 10) (om-make-point 428 40) (om-make-point 903 577) "" 908 0 "2023/10/26 12:12:23" "2023/10/27 23:11:18")
; End File Header
; External resources 
; (list (list (quote :abstraction) "#P\"leaps followed by a step in the opposite direction.omp\"" "#P\"no voice should make a leap greater than a 5th except with an ascending m6 - 1 input.omp\"" "#P\"raised-7th motion i.oml\"" "#P\"tritone leaps.omp\"" "#P\"leaps to open intervals.omp\"" "#P\"max interval between two voices - strict.omp\"" "#P\"opening 5th or octave.omp\"" "#P\"all vertical-intervals consonant.omp\"" "#P\"unison ending rule 2.omp\"" "#P\"prepared cadence rule 2.omp\"" "#P\"voice-overlap rule - 1-input.omp\"" "#P\"is consonant - strict.omp\"" "#P\"is consonant.omp\"" "#P\"dissonance-consonance rule 2.omp\"" "#P\"octaves ban.omp\"" "#P\"voice-crossing.omp\"" "#P\"consecutive open intervals 2.omp\"" "#P\"tritones across voices.omp\"" "#P\"dissonance-consonance rule.omp\"" "#P\"leaps to octaves 2.omp\"" "#P\"is a step.omp\"" "#P\"is dissonant - strict.omp\"" "#P\"is dissonant.omp\"" "#P\"is a step or a repeat.omp\"" "#P\"voice-escmotion folder/print inputs to voice-escmotion.omp\"" "#P\"voice-escmotion folder/is 1to2.omp\"" "#P\"voice-escmotion 3.omp\"" "#P\"similar motion into open intervals.omp\"" "#P\"transposition.omp\"" "#P\"repeated notes in voice2  ii.omp\"" "#P\"rule template.omp\""))
(in-package :om)(load-lib-for (quote ("myextension")))(setf *om-current-persistent* (om-load-patch1 "rules for strict 2-to-1 motion ex v2" (quote ((let ((box (om-load-boxcall (quote patch-box) "leaps followed by a step in the opposite direction" (quote ("elements" "strict polyphonic voice-motion" "leaps followed by a step in the opposite direction")) (quote ((om-load-inputfun (quote input-funbox) "" "input" (list 55 (list 55 57) 58 60 nil)))) (om-make-point 248 8) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "no voice should make a leap greater than a 5th except with an ascending m6 - 1 input 2" (quote ("elements" "strict polyphonic voice-motion" "no voice should make a leap greater than a 5th except with an ascending m6 - 1 input")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" nil))) (om-make-point 529 2) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CAR" (quote car) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 790 319) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "raised-7th motion i" (quote ("elements" "strict polyphonic voice-motion" "raised-7th motion i")) (quote ((om-load-inputfun (quote input-funbox) "" "SEQUENCE" nil) (om-load-inputfun (quote input-funbox) "" "TONIC-PC" nil))) (om-make-point 721 363) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "tritone leaps 2" (quote ("elements" "strict polyphonic voice-motion" "tritone leaps")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 379 94) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "leaps to open intervals" (quote ("elements" "strict polyphonic voice-motion" "leaps to open intervals")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 491 290) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 661 74) (om-make-point 32 28) 19 "19" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "max interval between two voices - strict" (quote ("elements" "strict polyphonic voice-motion" "max interval between two voices - strict")) (quote ((om-load-inputfun (quote input-funbox) "" "voice1 and voice2" (list 55 (list 55 57) 58 60 nil)) (om-load-inputfun (quote input-funbox) "" "max allowed interval" 19))) (om-make-point 525 104) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "opening 5th or octave" (quote ("elements" "strict polyphonic voice-motion" "opening 5th or octave")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 213 82) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "rules that apply at 1st species level" (om-load-patch-abs1 "rules that apply at 1st species level" (quote ((let ((box (om-load-boxcall (quote patch-box) "all vertical-intervals consonant" (quote ("elements" "strict polyphonic voice-motion" "all vertical-intervals consonant")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 288 151) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "unison ending rule" (quote ("elements" "strict polyphonic voice-motion" "unison ending rule 2")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 830 292) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "prepared cadence rule" (quote ("elements" "strict polyphonic voice-motion" "prepared cadence rule 2")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 662 250) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "voice-overlap rule - 1-input" (quote ("elements" "strict polyphonic voice-motion" "voice-overlap rule - 1-input")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" (list (list 60 62 64) (list 67 65 67) (list 70 69 67))))) (om-make-point 333 5) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "no voice should make a leap greater than a 5th except with an ascending m6 - 1 input" (quote ("elements" "strict polyphonic voice-motion" "no voice should make a leap greater than a 5th except with an ascending m6 - 1 input")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" nil))) (om-make-point 449 31) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "consonant vertical intervals" (om-load-patch-abs1 "consonant vertical intervals" (quote ((let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "mypatch" (quote ((let ((box (om-load-boxcall (quote patch-box) "is consonant - strict" (quote ("elements" "strict polyphonic voice-motion" "is consonant - strict")) (quote ((om-load-inputfun (quote input-funbox) "" "x" nil) (om-load-inputfun (quote input-funbox) "" "y" nil))) (om-make-point 42 117) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAP2?AND" (quote map2?and) (quote ((om-load-inputfun (quote input-funbox) "" "FN" nil) (om-load-inputfun (quote input-funbox) "" "LIST1" nil) (om-load-inputfun (quote input-funbox) "" "LIST2" nil))) (om-make-point 119 201) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 206 122) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FLATTEN-SEQC" (quote flatten-seqc) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 117 78) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 7 291) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is consonant" (quote ("elements" "strict polyphonic voice-motion" "is consonant")) (quote ((om-load-inputfun (quote input-funbox) "" "x" nil) (om-load-inputfun (quote input-funbox) "" "y" nil))) (om-make-point 501 84) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((0 0 1 0 nil 0) (2 0 1 1 nil 0) (2 1 1 2 nil 0) (3 0 2 0 nil 0) (5 0 3 0 nil 0) (1 0 4 0 nil 0))) 6.16 nil "" (om-make-point 374 98) (om-make-point 500 360)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 236 83) nil nil "l" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAP?AND" (quote map?and) (quote ((om-load-inputfun (quote input-funbox) "" "FN" nil) (om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 254 153) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "COMBINATIONS-OF2" (quote combinations-of2) (quote ((om-load-inputfun (quote input-funbox) "XS" "XS" nil))) (om-make-point 316 87) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 5 240) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((0 0 1 0 nil 0) (2 0 1 1 nil 0) (4 0 2 0 nil 0) (1 0 3 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 360)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 60 21) nil nil "l" "consonant vertical intervals"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "dissonance-consonance rule 2" (quote ("elements" "strict polyphonic voice-motion" "dissonance-consonance rule 2")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 759 223/2) nil nil "l" "dissonance-consonance rule 2" 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "octaves ban 2" (quote ("elements" "strict polyphonic voice-motion" "octaves ban")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 333 89) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "voice-crossing" (quote ("elements" "strict polyphonic voice-motion" "voice-crossing")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 162 89) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "consecutive open intervals" (quote ("elements" "strict polyphonic voice-motion" "consecutive open intervals 2")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" (list (list 60 62 64) (list 67 65 64) (list 72 72 72))))) (om-make-point 0 137) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 2 286) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ASSERT!! 2" (quote assert!!) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 0 237) (om-make-point 480 47) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "lispfunction" (om-load-lisp-abspatch "lispfunction" 6.16 "") (quote nil) (om-make-point 1056 442) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "tritones across voices" (quote ("elements" "strict polyphonic voice-motion" "tritones across voices")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" nil))) (om-make-point 353 429) nil nil "l" "tritones across voices" 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "dissonance-consonance rule" (quote ("elements" "strict polyphonic voice-motion" "dissonance-consonance rule")) (quote ((om-load-inputfun (quote input-funbox) "" "cf" nil) (om-load-inputfun (quote input-funbox) "" "voice2" nil) (om-load-inputfun (quote input-funbox) "" "vertical-intervals" nil) (om-load-inputfun (quote input-funbox) "" "voice-intervals" nil) (om-load-inputfun (quote input-funbox) "" "vertical-intervals%12" nil) (om-load-inputfun (quote input-funbox) "" "horizontal-intervals%12" nil) (om-load-inputfun (quote input-funbox) "" "horizontal-intervals-scale-degrees" nil) (om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 843 456) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "opening 5th or octave" (quote ("elements" "strict polyphonic voice-motion" "opening 5th or octave")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 193 2) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "no tritone leaps" (quote ("elements" "strict polyphonic voice-motion" "tritone leaps")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 64 72) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((12 0 11 0 nil 0) (10 0 12 0 nil 0) (9 0 12 1 nil 0) (17 0 12 3 nil 0) (8 0 12 4 nil 0) (16 0 12 5 nil 0) (6 0 12 6 nil 0) (5 0 12 7 nil 0) (0 0 12 11 nil 0))) 6.16 nil "" (om-make-point 355 34) (om-make-point 847 347)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 1 390) nil (list (list (list nil nil nil nil nil nil nil nil nil nil nil) (list nil nil nil nil nil nil nil nil nil nil nil))) nil "rules that apply at 1st species level"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ASSERT!!" (quote assert!!) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 138 396) (om-make-point 542 47) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "SEQUENCE" (quote sequence) (quote ((om-load-inputfun (quote input-funbox) "something" "PATCH" nil) (om-load-inputfun (quote input-funbox) "more things" "OPPATCH" nil))) (om-make-point 104 463) nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "as 1st species" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" nil))) (om-make-point 26 325) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS 3" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 24 127) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS 2" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 293 444) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CAR" (quote car) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 276 315) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REMOVE-IF" (quote remove-if) (quote ((om-load-inputfun (quote input-funbox) "PREDICATE" "PREDICATE" nil) (om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 278 249) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NULL" (quote null) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 248 155) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "SOME" (quote some) (quote ((om-load-inputfun (quote input-funbox) "PREDICATE" "PREDICATE" nil) (om-load-inputfun (quote input-funbox) "FIRST-SEQUENCE" "FIRST-SEQUENCE" nil))) (om-make-point 262 202) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 306 186) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FLATTEN-SEQC" (quote t2l::flatten-seqc) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 302 141) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 255 379) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 12 205) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "sequence" 0 (om-make-point 5 40) "" "sequence" (list (list 60 67 60 59) (list 72 71 72 74) (list 76 74 76 74)) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 300 510) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 200 510) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((10 0 0 0 nil 0) (8 1 1 0 nil 0) (3 0 2 0 nil 0) (5 0 3 0 nil 0) (6 0 3 1 nil 0) (4 0 5 0 nil 0) (7 0 6 0 nil 0) (9 0 7 0 nil 0) (2 0 8 0 nil 0) (0 0 9 0 nil 0) (1 0 11 0 nil 0) (8 0 12 0 nil 0))) 1 "as 1st species" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "leaps to octaves 2" (quote ("elements" "strict polyphonic voice-motion" "leaps to octaves 2")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 814 505/2) nil nil "l" "leaps to octaves" 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "dissonances in voice2 pass by step" (om-load-patch-abs1 "dissonances in voice2 pass by step" (quote ((let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 135 230) (om-make-point 26 28) (quote t) "T" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "HAS-NULL-VALUES" (quote has-null-values) (quote ((om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 39 170) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 123 260) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch 2" (om-load-patch-abs1 "mypatch 2" (quote ((let ((box (om-load-boxcall (quote abstraction) "voice2 moves by step to next group" (om-load-patch-abs1 "voice2 moves by step to next group" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 684 390) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 50 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?AND 4" (quote ?and) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 774 331) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS 8" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 703 125) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS 9" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 754 192) nil nil nil nil 3))) (setf (numouts box) 3) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is a step" (quote ("elements" "strict polyphonic voice-motion" "is a step")) (quote ((om-load-inputfun (quote input-funbox) "" "x1" nil) (om-load-inputfun (quote input-funbox) "" "x2" nil))) (om-make-point 740 255) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is a step 2" (quote ("elements" "strict polyphonic voice-motion" "is a step")) (quote ((om-load-inputfun (quote input-funbox) "" "x1" nil) (om-load-inputfun (quote input-funbox) "" "x2" nil))) (om-make-point 790 255) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 0 0 nil 0) (5 0 2 0 nil 0) (6 0 2 1 nil 0) (1 0 3 0 nil 0) (3 1 4 0 nil 0) (4 0 5 0 nil 0) (4 1 5 1 nil 0) (4 1 6 0 nil 0) (4 2 6 1 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 915 475)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 2871/5 603/5) nil nil nil "voice2 moves by step to next group"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "voice2 ascends or descends to next group" (om-load-patch-abs1 "voice2 ascends or descends to next group" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 649 390) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 50 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?OR 2" (quote ?or) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 595 266) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS 7" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 543 125) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?ALL<" (quote ?all<) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 561 204) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?ALL>" (quote ?all>) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 620 204) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 0 0 nil 0) (4 0 2 0 nil 0) (5 0 2 1 nil 0) (1 0 3 0 nil 0) (3 1 4 0 nil 0) (3 1 5 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 774 515)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 1407/4 483/4) nil nil nil "voice2 ascends or descends to next group"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "passing note is dissonant in voice2" (om-load-patch-abs1 "passing note is dissonant in voice2" (quote ((let ((box (om-load-boxcall (quote patch-box) "is dissonant - strict" (quote ("elements" "strict polyphonic voice-motion" "is dissonant - strict")) (quote ((om-load-inputfun (quote input-funbox) "" "x" nil) (om-load-inputfun (quote input-funbox) "" "y" nil))) (om-make-point 197 270) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 224 347) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 50 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 183 125) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS 2" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 154 192) nil nil nil nil 3))) (setf (numouts box) 3) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS 3" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 234 192) nil nil nil nil 3))) (setf (numouts box) 3) box))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((4 1 0 0 nil 0) (5 1 0 1 nil 0) (0 0 1 0 nil 0) (2 0 3 0 nil 0) (3 0 4 0 nil 0) (3 1 5 0 nil 0))) 6.16 nil "" (om-make-point 516 90) (om-make-point 359 432)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 164 120) nil nil "&" "passing note is dissonant in voice2"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?AND 3" (quote ?and) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 521 195) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?AND" (quote ?and) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 356 268) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?OR" (quote ?or) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 328 328) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?NOT" (quote ?not) (quote ((om-load-inputfun (quote input-funbox) "" "X" nil))) (om-make-point 303 283) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "first and last are consonant" (om-load-patch-abs1 "first and last are consonant" (quote ((let ((box (om-load-boxcall (quote patch-box) "is consonant - strict 2" (quote ("elements" "strict polyphonic voice-motion" "is consonant - strict")) (quote ((om-load-inputfun (quote input-funbox) "" "x" nil) (om-load-inputfun (quote input-funbox) "" "y" nil))) (om-make-point 130 261) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is consonant - strict" (quote ("elements" "strict polyphonic voice-motion" "is consonant - strict")) (quote ((om-load-inputfun (quote input-funbox) "" "x" nil) (om-load-inputfun (quote input-funbox) "" "y" nil))) (om-make-point 19 269) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 161 406) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 146 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?AND" (quote ?and) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 139 346) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS 4" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 79 125) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS 5" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 50 192) nil nil nil nil 3))) (setf (numouts box) 3) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS 6" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 130 192) nil nil nil nil 3))) (setf (numouts box) 3) box))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((6 2 0 0 nil 0) (7 2 0 1 nil 0) (6 0 1 0 nil 0) (7 0 1 1 nil 0) (4 0 2 0 nil 0) (1 0 4 0 nil 0) (0 0 4 1 nil 0) (3 0 5 0 nil 0) (5 0 6 0 nil 0) (5 1 7 0 nil 0))) 6.16 nil "" (om-make-point 646 90) (om-make-point 286 453)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 55/3 239/2) nil nil nil "first and last are consonant"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?AND 2" (quote ?and) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 277 386) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 50 456) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "group 2 to 1 motion with continuation" 0 (om-make-point 102 50) "" "group 2 to 1 motion with continuation" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((10 0 0 0 nil 0) (10 0 1 0 nil 0) (10 0 2 0 nil 0) (1 0 3 0 nil 0) (0 0 3 1 nil 0) (2 0 4 0 nil 0) (3 0 4 1 nil 0) (6 0 5 0 nil 0) (4 0 5 1 nil 0) (2 0 6 0 nil 0) (10 0 7 0 nil 0) (7 0 8 0 nil 0) (5 0 8 1 nil 0) (8 0 9 0 nil 0))) 6.16 nil "" (om-make-point 528 58) (om-make-point 768 456)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 118 1072/7) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "mypatch" (quote ((let ((box (om-load-boxcall (quote patch-box) "is dissonant" (quote ("elements" "strict polyphonic voice-motion" "is dissonant")) (quote ((om-load-inputfun (quote input-funbox) "" "x" nil) (om-load-inputfun (quote input-funbox) "" "y" nil))) (om-make-point 460 140) nil nil "&" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 168 339) (om-make-point 24 28) (quote t) "t" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 156 369) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "HAS-NULL-VALUES 3" (quote t2l::has-null-values) (quote ((om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 179 194) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 179 194)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST 3" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 193 142) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "HAS-NULL-VALUES 2" (quote t2l::has-null-values) (quote ((om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 92 194) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 92 194)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST 2" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 123 142) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 33 142) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "HAS-NULL-VALUES" (quote t2l::has-null-values) (quote ((om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 2 194) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 2 194)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "active voice1" (om-load-patch-abs1 "active voice1" (quote ((let ((box (om-load-boxin "x2 and y2 are dissonant" 6 (om-make-point 302 242) "" "x2 and y2 are dissonant" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ORV 2" (quote screamer:orv) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 241 361) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NOTV" (quote screamer:notv) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 254 318) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 161 429) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "y3" 5 (om-make-point 255 0) "" "y3" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "y2" 4 (om-make-point 223 0) "" "y2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "y1" 3 (om-make-point 190 0) "" "y1" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "x3" 2 (om-make-point 155 10) "" "x3" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "x2" 1 (om-make-point 124 10) "" "x2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "x1" 0 (om-make-point 90 10) "" "x1" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ANDV 4" (quote screamer:andv) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 204 615/2) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "OM<=V 3" (quote t2l::om<=v) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 292 307/2) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 292 307/2)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "OM>=V 2" (quote t2l::om>=v) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 182 307/2) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 182 307/2)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ANDV" (quote screamer:andv) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 270 417/2) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ORV" (quote screamer:orv) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 217 519/2) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ANDV 2" (quote screamer:andv) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 160 417/2) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "OM>V" (quote t2l::om>v) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 244 307/2) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 244 307/2)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "OM<V" (quote t2l::om<v) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 137 307/2) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 137 307/2)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is a step or a repeat 3" (quote ("elements" "strict polyphonic voice-motion" "is a step or a repeat")) (quote ((om-load-inputfun (quote input-funbox) "" "x1" nil) (om-load-inputfun (quote input-funbox) "" "x2" nil))) (om-make-point 450 307/2) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is a step 3" (quote ("elements" "strict polyphonic voice-motion" "is a step")) (quote ((om-load-inputfun (quote input-funbox) "" "x1" nil) (om-load-inputfun (quote input-funbox) "" "x2" nil))) (om-make-point 91 307/2) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is a step 4" (quote ("elements" "strict polyphonic voice-motion" "is a step")) (quote ((om-load-inputfun (quote input-funbox) "" "x1" nil) (om-load-inputfun (quote input-funbox) "" "x2" nil))) (om-make-point 41 307/2) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is a step or a repeat 4" (quote ("elements" "strict polyphonic voice-motion" "is a step or a repeat")) (quote ((om-load-inputfun (quote input-funbox) "" "x1" nil) (om-load-inputfun (quote input-funbox) "" "x2" nil))) (om-make-point 340 307/2) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment 2" (om-make-point 100 60) (quote "voice1 active, voice2 passive") "" (om-make-point 161 82) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((10 0 1 0 nil 0) (2 0 1 1 nil 0) (0 0 2 0 nil 0) (1 0 3 0 nil 0) (20 0 10 0 nil 0) (19 0 10 1 nil 0) (14 0 10 2 nil 0) (21 0 10 3 nil 0) (18 0 10 4 nil 0) (0 0 10 5 nil 0) (6 0 11 0 nil 0) (5 0 11 1 nil 0) (4 0 11 2 nil 0) (6 0 12 0 nil 0) (5 0 12 1 nil 0) (4 0 12 2 nil 0) (16 0 13 0 nil 0) (11 0 13 1 nil 0) (15 0 14 0 nil 0) (13 0 14 1 nil 0) (17 0 15 0 nil 0) (12 0 15 1 nil 0) (9 0 16 0 nil 0) (8 0 16 1 nil 0) (7 0 16 2 nil 0) (9 0 17 0 nil 0) (8 0 17 1 nil 0) (7 0 17 2 nil 0) (5 0 18 0 nil 0) (4 0 18 1 nil 0) (8 0 19 0 nil 0) (7 0 19 1 nil 0) (9 0 20 0 nil 0) (8 0 20 1 nil 0) (6 0 21 0 nil 0) (5 0 21 1 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "x1" nil) (om-load-inputfun (quote input-funbox) "" "x2" nil) (om-load-inputfun (quote input-funbox) "" "x3" nil) (om-load-inputfun (quote input-funbox) "" "y1" nil) (om-load-inputfun (quote input-funbox) "" "y2" nil) (om-load-inputfun (quote input-funbox) "" "y3" nil) (om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 7144/13 2918/13) nil nil nil "active voice1"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "active voice2" (om-load-patch-abs1 "active voice2" (quote ((let ((box (om-load-boxin "x2 and y2 are dissonant" 6 (om-make-point 555 235) "" "x2 and y2 are dissonant" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NOTV" (quote screamer:notv) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 384 366) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ORV" (quote screamer:orv) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 371 409) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 4962/13 460) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "y3" 5 (om-make-point 7185/13 40) "" "y3" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "y2" 4 (om-make-point 6769/13 40) "" "y2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "y1" 3 (om-make-point 6340/13 40) "" "y1" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "x3" 2 (om-make-point 5365/13 50) "" "x3" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "x2" 1 (om-make-point 4962/13 50) "" "x2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "x1" 0 (om-make-point 4520/13 50) "" "x1" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ANDV 3" (quote screamer:andv) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 334 356) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is a step or a repeat 2" (quote ("elements" "strict polyphonic voice-motion" "is a step or a repeat")) (quote ((om-load-inputfun (quote input-funbox) "" "x1" nil) (om-load-inputfun (quote input-funbox) "" "x2" nil))) (om-make-point 50 202) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is a step 2" (quote ("elements" "strict polyphonic voice-motion" "is a step")) (quote ((om-load-inputfun (quote input-funbox) "" "x1" nil) (om-load-inputfun (quote input-funbox) "" "x2" nil))) (om-make-point 451 202) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is a step" (quote ("elements" "strict polyphonic voice-motion" "is a step")) (quote ((om-load-inputfun (quote input-funbox) "" "x1" nil) (om-load-inputfun (quote input-funbox) "" "x2" nil))) (om-make-point 501 202) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is a step or a repeat" (quote ("elements" "strict polyphonic voice-motion" "is a step or a repeat")) (quote ((om-load-inputfun (quote input-funbox) "" "x1" nil) (om-load-inputfun (quote input-funbox) "" "x2" nil))) (om-make-point 160 202) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "OM<=V 2" (quote t2l::om<=v) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 262 202) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 262 202)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "OM>=V" (quote t2l::om>=v) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 372 202) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 372 202)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ANDV 6" (quote screamer:andv) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 400 257) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ORV 2" (quote screamer:orv) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 347 308) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ANDV 5" (quote screamer:andv) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 290 257) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "OM>V 2" (quote t2l::om>v) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 314 202) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 314 202)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((newbox (om-load-boxcall (quote genfun) "OM<V 2" (quote t2l::om<v) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 427 202) nil nil nil nil 1))) (setf (frame-position newbox) (om-make-point 427 202)) newbox))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 100 60) (quote "voice2 active, voice1 passive") "" (om-make-point 223 131) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((0 0 1 0 nil 0) (10 0 2 0 nil 0) (1 0 2 1 nil 0) (2 0 3 0 nil 0) (11 0 10 0 nil 0) (14 0 10 1 nil 0) (18 0 10 2 nil 0) (12 0 10 3 nil 0) (13 0 10 4 nil 0) (0 0 10 5 nil 0) (9 0 11 0 nil 0) (8 0 11 1 nil 0) (6 0 12 0 nil 0) (5 0 12 1 nil 0) (5 0 13 0 nil 0) (4 0 13 1 nil 0) (8 0 14 0 nil 0) (7 0 14 1 nil 0) (9 0 15 0 nil 0) (8 0 15 1 nil 0) (7 0 15 2 nil 0) (9 0 16 0 nil 0) (8 0 16 1 nil 0) (7 0 16 2 nil 0) (16 0 17 0 nil 0) (21 0 17 1 nil 0) (19 0 18 0 nil 0) (17 0 18 1 nil 0) (15 0 19 0 nil 0) (20 0 19 1 nil 0) (6 0 20 0 nil 0) (5 0 20 1 nil 0) (4 0 20 2 nil 0) (6 0 21 0 nil 0) (5 0 21 1 nil 0) (4 0 21 2 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "x1" nil) (om-load-inputfun (quote input-funbox) "" "x2" nil) (om-load-inputfun (quote input-funbox) "" "x3" nil) (om-load-inputfun (quote input-funbox) "" "y1" nil) (om-load-inputfun (quote input-funbox) "" "y2" nil) (om-load-inputfun (quote input-funbox) "" "y3" nil) (om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 3316/13 225) nil nil nil "active voice2"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ORV 4" (quote screamer:orv) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 271 319) (om-make-point 203 42) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 119 438) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "y3" 5 (om-make-point 420 50) "" "y3" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "y2" 4 (om-make-point 388 50) "" "y2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "y1" 3 (om-make-point 355 50) "" "y1" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "x3" 2 (om-make-point 280 50) "" "x3" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "x2" 1 (om-make-point 249 50) "" "x2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "x1" 0 (om-make-point 215 50) "" "x1" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((17 0 0 0 nil 0) (14 0 0 1 nil 0) (3 0 2 0 nil 0) (1 0 2 1 nil 0) (11 0 2 2 nil 0) (4 0 3 0 nil 0) (18 0 4 0 nil 0) (17 0 4 1 nil 0) (16 0 4 2 nil 0) (15 0 4 3 nil 0) (14 0 4 4 nil 0) (13 0 4 5 nil 0) (6 0 5 0 nil 0) (16 0 6 0 nil 0) (13 0 6 1 nil 0) (17 0 7 0 nil 0) (14 0 7 1 nil 0) (7 0 8 0 nil 0) (18 0 9 0 nil 0) (17 0 9 1 nil 0) (16 0 9 2 nil 0) (15 0 9 3 nil 0) (14 0 9 4 nil 0) (13 0 9 5 nil 0) (0 0 9 6 nil 0) (18 0 10 0 nil 0) (17 0 10 1 nil 0) (16 0 10 2 nil 0) (15 0 10 3 nil 0) (14 0 10 4 nil 0) (13 0 10 5 nil 0) (0 0 10 6 nil 0) (10 0 11 0 nil 0) (9 0 11 1 nil 0) (2 0 12 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "x1" nil) (om-load-inputfun (quote input-funbox) "" "x2" nil) (om-load-inputfun (quote input-funbox) "" "x3" nil) (om-load-inputfun (quote input-funbox) "" "x4" nil) (om-load-inputfun (quote input-funbox) "" "y1" nil) (om-load-inputfun (quote input-funbox) "" "y2" nil))) (om-make-point 300 134) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 154 50) (quote "((x1 y1) (x2 y2) ...)") "" (om-make-point 75 11) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 18 352) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 11 49) "" nil (list (list (quote x1) (quote x1) (quote x1)) (list (quote y1) (quote y2) (quote y3))) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((7 0 1 0 nil 0) (1 0 2 0 nil 0) (0 0 2 1 nil 0) (3 0 2 2 nil 0) (7 0 3 0 nil 0) (2 0 6 0 nil 0))) 6.16 nil "" (om-make-point 616 172) (om-make-point 500 320)) (quote ((om-load-inputfun (quote input-funbox) "" "input" (list (list (quote x1) (quote x1) (quote x1)) (list (quote y1) (quote y2) (quote y3)))))) (om-make-point 316 206) nil nil "l" "dissonances in voice2 pass by step"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "print inputs to voice-escmotion" (quote ("elements" "strict polyphonic voice-motion" "voice-escmotion folder" "print inputs to voice-escmotion")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" nil))) (om-make-point 1020 275) nil nil "l" "print inputs to voice-escmotion" 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is 1to2" (quote ("elements" "strict polyphonic voice-motion" "voice-escmotion folder" "is 1to2")) (quote ((om-load-inputfun (quote input-funbox) "" "input" (list (list 62 62 60) (list 69 70 72))))) (om-make-point 274 206) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "voice-escmotion 3" (quote ("elements" "strict polyphonic voice-motion" "voice-escmotion 3")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" nil) (om-load-inputfun (quote input-funbox) "" "select-motion-type fn" nil) (om-load-inputfun (quote input-funbox) "" "rule-definition fn" nil))) (om-make-point 238 286) nil nil "l" "voice-escmotion 3" 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "tritones across voices" (quote ("elements" "strict polyphonic voice-motion" "tritones across voices")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" (list 62 67 65 64 65 64 62)))) (om-make-point 998 373) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "similar motion into open intervals" (quote ("elements" "strict polyphonic voice-motion" "similar motion into open intervals")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 610 464) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "mode-pcset" 1 (om-make-point 124 78) "" "mode-pcset" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "modality" (quote ("elements" "strict polyphonic voice-motion" "transposition")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" nil) (om-load-inputfun (quote input-funbox) "" "scale-pcset" nil))) (om-make-point 85 418/3) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "voice-overlap rule - 1-input - 1st species" (om-load-patch-abs1 "voice-overlap rule - 1-input - 1st species" (quote ((let ((box (om-load-boxcall (quote patch-box) "voice-overlap rule - 1-input" (quote ("elements" "strict polyphonic voice-motion" "voice-overlap rule - 1-input")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" (list (list 60 62 64) (list 67 65 67) (list 70 69 67))))) (om-make-point 106 216) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "as 1st species" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" nil))) (om-make-point 81 130) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS 3" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 24 127) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS 2" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 293 444) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CAR" (quote car) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 276 315) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REMOVE-IF" (quote remove-if) (quote ((om-load-inputfun (quote input-funbox) "PREDICATE" "PREDICATE" nil) (om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 278 249) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NULL" (quote null) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 248 155) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "SOME" (quote some) (quote ((om-load-inputfun (quote input-funbox) "PREDICATE" "PREDICATE" nil) (om-load-inputfun (quote input-funbox) "FIRST-SEQUENCE" "FIRST-SEQUENCE" nil))) (om-make-point 262 202) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 306 186) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FLATTEN-SEQC" (quote t2l::flatten-seqc) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 302 141) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 255 379) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 12 205) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "sequence" 0 (om-make-point 5 40) "" "sequence" (list (list 60 67 60 59) (list 72 71 72 74) (list 76 74 76 74)) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 300 510) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 200 510) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((10 0 0 0 nil 0) (8 1 1 0 nil 0) (3 0 2 0 nil 0) (5 0 3 0 nil 0) (6 0 3 1 nil 0) (4 0 5 0 nil 0) (7 0 6 0 nil 0) (9 0 7 0 nil 0) (2 0 8 0 nil 0) (0 0 9 0 nil 0) (1 0 11 0 nil 0) (8 0 12 0 nil 0))) 1 "as 1st species" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 43 389) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "sequence" 0 (om-make-point 5 45) "" "sequence" (list (list 60 62 64) (list 67 65 67) (list 70 69 67)) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (3 0 1 0 nil 0) (0 0 2 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" (list (list 60 62 64) (list 67 65 67) (list 70 69 67))))) (om-make-point 795 110) nil nil "l" "voice-overlap rule - 1-input - 1st species"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "voice-overlap rule - 1-input" (quote ("elements" "strict polyphonic voice-motion" "voice-overlap rule - 1-input")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" (list (list 60 62 64) (list 67 65 67) (list 70 69 67))))) (om-make-point 335 301) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "leaps to octaves" (quote ("elements" "strict polyphonic voice-motion" "leaps to octaves 2")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 1000 531) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "consecutive open intervals" (quote ("elements" "strict polyphonic voice-motion" "consecutive open intervals 2")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" (list (list 60 62 64) (list 67 65 64) (list 72 72 72))))) (om-make-point 411 133) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "voice overlap - delete" (om-load-patch-abs1 "voice overlap - delete" (quote ((let ((box (om-load-boxcall (quote genfun) "?ALL<=" (quote ?all<=) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 328 131) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "HAS-NULL-VALUES" (quote has-null-values) (quote ((om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 387 22) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REMOVE-IF" (quote remove-if) (quote ((om-load-inputfun (quote input-funbox) "PREDICATE" "PREDICATE" nil) (om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 437 105) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 520 71) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAP?AND" (quote map?and) (quote ((om-load-inputfun (quote input-funbox) "" "FN" nil) (om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 361 199) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 348 300) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 50 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FLATTEN-SEQC" (quote flatten-seqc) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 501 23) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 2 0 nil 0) (3 0 2 1 nil 0) (7 0 3 0 nil 0) (0 0 4 0 nil 0) (2 0 4 1 nil 0) (4 0 5 0 nil 0) (6 0 7 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 2901/4 607/4) nil nil "l" "voice overlap - delete"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "prepared cadence rule" (quote ("elements" "strict polyphonic voice-motion" "prepared cadence rule 2")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 696 221) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "unison ending rule" (quote ("elements" "strict polyphonic voice-motion" "unison ending rule 2")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 254 141) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "consecutive open intervals - 1st species" (om-load-patch-abs1 "consecutive open intervals - 1st species" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 0 256) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 0 43) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "as 1st species" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" nil))) (om-make-point 63 115) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS 3" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 24 127) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS 2" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 293 444) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CAR" (quote car) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 276 315) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REMOVE-IF" (quote remove-if) (quote ((om-load-inputfun (quote input-funbox) "PREDICATE" "PREDICATE" nil) (om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 278 249) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NULL" (quote null) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 248 155) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "SOME" (quote some) (quote ((om-load-inputfun (quote input-funbox) "PREDICATE" "PREDICATE" nil) (om-load-inputfun (quote input-funbox) "FIRST-SEQUENCE" "FIRST-SEQUENCE" nil))) (om-make-point 262 202) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 306 186) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FLATTEN-SEQC" (quote t2l::flatten-seqc) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 302 141) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 255 379) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 12 205) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "sequence" 0 (om-make-point 5 40) "" "sequence" (list (list 60 67 60 59) (list 72 71 72 74) (list 76 74 76 74)) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 300 510) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 200 510) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((10 0 0 0 nil 0) (8 1 1 0 nil 0) (3 0 2 0 nil 0) (5 0 3 0 nil 0) (6 0 3 1 nil 0) (4 0 5 0 nil 0) (7 0 6 0 nil 0) (9 0 7 0 nil 0) (2 0 8 0 nil 0) (0 0 9 0 nil 0) (1 0 11 0 nil 0) (8 0 12 0 nil 0))) 1 "as 1st species" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "consecutive open intervals" (quote ("elements" "strict polyphonic voice-motion" "consecutive open intervals 2")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" (list (list 60 62 64) (list 67 65 64) (list 72 72 72))))) (om-make-point 36 177) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((3 0 0 0 nil 0) (1 0 2 0 nil 0) (2 0 3 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 1329/2 1055/2) nil (list nil) "l" "consecutive open intervals - 1st species"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "leaps to octaves - 1st species" (om-load-patch-abs1 "leaps to octaves - 1st species" (quote ((let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 50 50) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "leaps to octaves 2" (quote ("elements" "strict polyphonic voice-motion" "leaps to octaves 2")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 542 435/2) nil nil nil "leaps to octaves" 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "as 1st species" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" nil))) (om-make-point 471 150) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS 3" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 24 127) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS 2" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 293 444) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CAR" (quote car) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 276 315) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REMOVE-IF" (quote remove-if) (quote ((om-load-inputfun (quote input-funbox) "PREDICATE" "PREDICATE" nil) (om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 278 249) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NULL" (quote null) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 248 155) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "SOME" (quote some) (quote ((om-load-inputfun (quote input-funbox) "PREDICATE" "PREDICATE" nil) (om-load-inputfun (quote input-funbox) "FIRST-SEQUENCE" "FIRST-SEQUENCE" nil))) (om-make-point 262 202) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 306 186) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FLATTEN-SEQC" (quote t2l::flatten-seqc) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 302 141) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 255 379) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 12 205) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "sequence" 0 (om-make-point 5 40) "" "sequence" (list (list 60 67 60 59) (list 72 71 72 74) (list 76 74 76 74)) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 300 510) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 200 510) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((10 0 0 0 nil 0) (8 1 1 0 nil 0) (3 0 2 0 nil 0) (5 0 3 0 nil 0) (6 0 3 1 nil 0) (4 0 5 0 nil 0) (7 0 6 0 nil 0) (9 0 7 0 nil 0) (2 0 8 0 nil 0) (0 0 9 0 nil 0) (1 0 11 0 nil 0) (8 0 12 0 nil 0))) 1 "as 1st species" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 1 0 nil 0) (3 0 2 0 nil 0) (0 0 3 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 2243/2 2027/4) nil nil "l" "leaps to octaves - 1st species"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "all vertical-intervals consonant - 1st species" (om-load-patch-abs1 "all vertical-intervals consonant - 1st species" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 50 230) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 50 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "all vertical-intervals consonant" (quote ("elements" "strict polyphonic voice-motion" "all vertical-intervals consonant")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 275/2 112) nil nil nil "all vertical-intervals consonant" 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "as 1st species" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" nil))) (om-make-point 60 101) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS 3" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 24 127) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS 2" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 293 444) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CAR" (quote car) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 276 315) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REMOVE-IF" (quote remove-if) (quote ((om-load-inputfun (quote input-funbox) "PREDICATE" "PREDICATE" nil) (om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 278 249) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NULL" (quote null) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 248 155) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "SOME" (quote some) (quote ((om-load-inputfun (quote input-funbox) "PREDICATE" "PREDICATE" nil) (om-load-inputfun (quote input-funbox) "FIRST-SEQUENCE" "FIRST-SEQUENCE" nil))) (om-make-point 262 202) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 306 186) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FLATTEN-SEQC" (quote t2l::flatten-seqc) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 302 141) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 255 379) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 12 205) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "sequence" 0 (om-make-point 5 40) "" "sequence" (list (list 60 67 60 59) (list 72 71 72 74) (list 76 74 76 74)) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 300 510) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 200 510) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((10 0 0 0 nil 0) (8 1 1 0 nil 0) (3 0 2 0 nil 0) (5 0 3 0 nil 0) (6 0 3 1 nil 0) (4 0 5 0 nil 0) (7 0 6 0 nil 0) (9 0 7 0 nil 0) (2 0 8 0 nil 0) (0 0 9 0 nil 0) (1 0 11 0 nil 0) (8 0 12 0 nil 0))) 1 "as 1st species" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 0 0 nil 0) (3 0 2 0 nil 0) (1 0 3 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 2991/4 1307/2) nil (list nil) "l" "all vertical-intervals consonant - 1st species"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "repeated notes in voice2  ii" (quote ("elements" "strict polyphonic voice-motion" "repeated notes in voice2  ii")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 853 1051/2) nil nil "l" "repeated notes in voice2  ii" 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 150 527) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "rule template" (quote ("elements" "strict polyphonic voice-motion" "rule template")) (quote ((om-load-inputfun (quote input-funbox) "" "input" (list 55 (list 55 57) 58 60 nil)))) (om-make-point 640 313) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "no voice should make a leap greater than a 5th except with an ascending m6 - 1 input" (quote ("elements" "strict polyphonic voice-motion" "no voice should make a leap greater than a 5th except with an ascending m6 - 1 input")) (quote ((om-load-inputfun (quote input-funbox) "" "sequence" nil))) (om-make-point 782 603) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 158 250) "A list structure with containing lists of MIDI values corresponding to voices. A two-voice counterpoint example would contain two lists, for instance." nil (list (list 62 65 62) (list (list nil 74) (list 69 72) (list 74))) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((20 0 2 0 nil 0) (2 0 3 1 nil 0) (6 0 7 1 nil 0) (12 0 9 0 nil 0) (36 0 10 0 nil 0) (21 0 10 1 nil 0) (8 0 10 2 nil 0) (28 0 10 3 nil 0) (17 0 10 4 nil 0) (23 0 10 5 nil 0) (25 0 10 6 nil 0) (5 0 10 7 nil 0) (7 0 10 8 nil 0) (4 0 10 9 nil 0) (1 0 10 10 nil 0) (0 0 10 11 nil 0) (9 0 11 0 nil 0) (10 0 11 1 nil 0) (36 0 12 0 nil 0) (16 0 17 1 nil 0) (14 0 17 2 nil 0) (20 0 21 1 nil 0) (11 1 33 0 nil 0))) nil 6.16))