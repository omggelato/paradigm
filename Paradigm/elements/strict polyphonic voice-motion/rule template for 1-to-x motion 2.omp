; OM File Header - Saved 2022/12/30 3:32:07
; (6.16 :patc (om-make-point 280 110) (om-make-point 630 64) (om-make-point 522 306) "" 908 0 "2022/12/17 03:13:06" "2022/12/29 20:29:45")
; End File Header
(in-package :om)(load-lib-for (quote ("myextension")))(setf *om-current-persistent* (om-load-patch1 "rule template for 1-to-x motion 2" (quote ((let ((box (om-load-boxcall (quote abstraction) "rule definition" (om-load-patch-abs1 "rule definition" (quote ((let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 21 210) (om-make-point 24 28) (quote t) "t" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 5 240) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((0 0 1 0 nil 0))) 6.16 nil "" (om-make-point 499 168) (om-make-point 500 380)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 350 47) (om-make-point 77 66) nil "l" "rule definition"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "select motion type 2" (om-load-patch-abs1 "select motion type" (quote ((let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 41 210) (om-make-point 31 28) nil "nil" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 5 240) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((0 0 1 0 nil 0))) 6.16 nil "" (om-make-point 580 115) (om-make-point 500 380)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 144 36) nil nil "l" "select motion type"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "mypatch" (quote ((let ((box (om-load-boxcall (quote genfun) "MAP?AND" (quote map?and) (quote ((om-load-inputfun (quote input-funbox) "" "FN" nil) (om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 85 301) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REMOVE-IF-NOT" (quote remove-if-not) (quote ((om-load-inputfun (quote input-funbox) "PREDICATE" "PREDICATE" nil) (om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 51 248) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "GROUP-BY-MOTION-TYPE" (quote group-by-motion-type) (quote ((om-load-inputfun (quote input-funbox) "" "VOICE1" nil) (om-load-inputfun (quote input-funbox) "" "VOICE2" nil))) (om-make-point 57 187) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "rule-definition" 2 (om-make-point 217 46) "" "rule-definition" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "select-fn" 1 (om-make-point 161 47) "" "select-fn" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 83 118) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 60 385) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((3 0 0 0 nil 0) (1 0 0 1 nil 0) (4 0 1 0 nil 0) (2 0 1 1 nil 0) (5 0 2 0 nil 0) (5 1 2 1 nil 0) (7 0 5 0 nil 0) (0 0 6 0 nil 0))) 6.16 nil "" (om-make-point 436 92) (om-make-point 400 435)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil) (om-load-inputfun (quote input-funbox) "" "input 3" nil))) (om-make-point 137 161) nil nil nil "mypatch"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "COMBINATIONS-OF2" (quote t2l::combinations-of2) (quote ((om-load-inputfun (quote input-funbox) "XS" "XS" nil))) (om-make-point 89 93) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "select motion type" (om-load-lisp-abspatch "select motion type" 6.16 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (input)$  ;; filter-by-motion-type$  T)") (quote ((om-load-inputfun (quote input-funbox) "" "INPUT" nil))) (om-make-point 234 6) nil nil "l" "select motion type"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 88 245) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "sequence" 0 (om-make-point 21 27) "" "sequence" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((3 0 2 0 nil 0) (1 0 2 1 nil 0) (0 0 2 2 nil 0) (6 0 3 0 nil 0) (2 0 5 0 nil 0))) nil 6.16))
