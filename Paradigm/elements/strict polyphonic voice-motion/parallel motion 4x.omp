; OM File Header - Saved 2022/12/14 18:12:59
; (7.02 :patc (om-make-point 603.9844 610) (om-make-point 373 0) (om-make-point 502 640) "" 908 0 "2022/11/15 22:47:04" "2022/11/15 23:12:10")
; End File Header
(in-package :om)(load-lib-for (quote ("myextension")))(setf *om-current-persistent* (om-load-patch1 "parallel motion 4x" (quote ((let ((box (om-load-seqbox "SEQUENCE 2" (quote sequence) (quote ((om-load-inputfun (quote input-funbox) "something" "PATCH" nil) (om-load-inputfun (quote input-funbox) "more things" "OPPATCH" nil))) (om-make-point 128 511) nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR 2" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 90 462) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "COMBINATIONS-OF2" (quote t2l::combinations-of2) (quote ((om-load-inputfun (quote input-funbox) "XS" "XS" nil))) (om-make-point 243 168) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "remove note pairs that have null values" (om-load-patch-abs1 "remove note pairs that have null values" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 5 240) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR 4" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 127 163) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "HAS-NULL-VALUES" (quote t2l::has-null-values) (quote ((om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 50 50) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REMOVE-IF" (quote remove-if) (quote ((om-load-inputfun (quote input-funbox) "PREDICATE" "PREDICATE" nil) (om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 87 113) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 0 0 nil 0) (4 0 2 0 nil 0) (1 0 2 1 nil 0) (3 0 4 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 73 569/3) nil (list nil) "l" "remove note pairs that have null values"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR 5" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 176 264) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "interval%12" (om-load-patch-abs1 "interval%12" (quote ((let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 192 93) nil nil "&" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAP-FUNC 2" (quote t2l::map-func) (quote ((om-load-inputfun (quote input-funbox) "FN" "FN" nil) (om-load-inputfun (quote input-funbox) "TREE" "TREE" nil))) (om-make-point 47 299) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAP-FUNC" (quote t2l::map-func) (quote ((om-load-inputfun (quote input-funbox) "FN" "FN" nil) (om-load-inputfun (quote input-funbox) "TREE" "TREE" nil))) (om-make-point 195 384) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 196 307) (om-make-point 32 28) 12 "12" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "%V" (quote t2l::%v) (quote ((om-load-inputfun (quote input-funbox) "N" "N" nil) (om-load-inputfun (quote input-funbox) "D" "D" nil))) (om-make-point 182 337) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ABSV" (quote t2l::absv) (quote ((om-load-inputfun (quote input-funbox) "K" "K" nil))) (om-make-point 25 250) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS 2" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 141 160) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 84 229) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-V" (quote t2l::om-v) (quote ((om-load-inputfun (quote input-funbox) "" "X" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 27 168) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 61 160) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 5 450) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "all combinations of two notes in a chord" 0 (om-make-point 95 32) "" "all combinations of two notes in a chord" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((11 0 0 0 nil 0) (5 0 1 0 nil 0) (7 0 1 1 nil 0) (4 0 2 0 nil 0) (1 0 2 1 nil 0) (3 0 4 1 nil 0) (0 0 6 0 nil 0) (8 0 7 0 nil 0) (9 1 7 1 nil 0) (6 0 7 2 nil 0) (0 0 9 0 nil 0) (2 0 10 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 20 239) nil (list nil) "l" "interval%12"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR 3" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 59 312) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 282 212) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch 2" (om-load-patch-abs1 "mypatch" (quote ((let ((box (om-load-boxcall (quote lispfun) "MAPCAR" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 67 268) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "compare1" (om-load-patch-abs1 "compare1" (quote ((let ((box (om-load-boxcall (quote lispfun) "MAPCAR" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 131 185) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "compare chord2 against interval" (om-load-patch-abs1 "compare chord2 against interval" (quote ((let ((box (om-load-boxcall (quote genfun) "ASSERT!!" (quote t2l::assert!!) (quote ((om-load-inputfun (quote input-funbox) "" "SEQUENCE" nil))) (om-make-point 112 301) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMNOTV 2" (quote t2l::omnotv) (quote ((om-load-inputfun (quote input-funbox) "" "X" nil))) (om-make-point 199 199) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 181 108) (om-make-point 26 28) 7 "7" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=V 2" (quote t2l::om=v) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 206 138) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMNOTV" (quote t2l::omnotv) (quote ((om-load-inputfun (quote input-funbox) "" "X" nil))) (om-make-point 79 199) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 61 108) (om-make-point 26 28) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=V" (quote t2l::om=v) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 86 138) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMANDV 3" (quote t2l::omandv) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 133 249) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "interval2" 1 (om-make-point 125 27) "" "interval2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 108 377) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "interval1" 0 (om-make-point 50 50) "" "interval1" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((7 0 0 0 nil 0) (3 0 1 0 nil 0) (2 0 3 0 nil 0) (10 0 3 1 nil 0) (8 0 3 2 nil 0) (6 0 4 0 nil 0) (5 0 6 0 nil 0) (10 0 6 1 nil 0) (8 0 6 2 nil 0) (4 0 7 0 nil 0) (1 0 7 1 nil 0) (0 0 9 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 422)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 31 111) nil nil "l" "compare chord2 against interval"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 5 240) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord2 intervals" 1 (om-make-point 185 45) "" "chord2 intervals" (list 0 5 7) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "interval" 0 (om-make-point 135 45) "" "interval" 4 nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (3 0 0 1 nil 0) (4 0 1 1 nil 0) (0 0 2 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 360)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 27 183) nil (list nil) "l" "compare1"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS 3" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 67 114) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 5 334) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord-intervals-list-pair" 0 (om-make-point 5 45) "" "chord-intervals-list-pair" (list (list 7 0 5) (list 3 10 7)) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (2 1 0 1 nil 0) (2 0 1 1 nil 0) (4 0 2 0 nil 0) (0 0 3 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 360)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 54 384) nil (list nil) "l" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 159 350) (om-make-point 26 28) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 130 350) (om-make-point 26 28) 2 "2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "NSUCC" (quote t2l::nsucc) (quote ((om-load-inputfun (quote input-funbox) "" "INPUT" nil) (om-load-inputfun (quote input-funbox) "" "N" nil) (om-load-inputkeyword (quote input-keyword) "" "step" (quote :step) nil nil))) (om-make-point 116 380) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 352 149) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FLATTEN-SEQC" (quote t2l::flatten-seqc) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 348 104) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 0 570) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "sequence" 0 (om-make-point 0 34) "" "sequence" (list (list 60 62 64) (list 67 65 64) (list 72 72 72)) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (15 0 0 1 nil 0) (8 0 1 0 nil 0) (11 0 1 1 nil 0) (3 0 4 0 nil 0) (7 0 4 1 nil 0) (5 0 6 0 nil 0) (4 0 6 1 nil 0) (2 0 7 0 nil 0) (12 0 7 1 nil 0) (6 0 11 0 nil 0) (10 0 11 1 nil 0) (9 0 11 2 nil 0) (13 0 12 0 nil 0) (15 0 13 0 nil 0) (0 1 14 0 nil 0))) nil 6.16))
