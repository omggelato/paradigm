; OM File Header - Saved 2023/10/27 23:11:17
; (6.16 :patc (om-make-point 24 24) (om-make-point 322 0) (om-make-point 516 498) "" 908 0 nil "2023/10/27 23:11:17")
; End File Header
; External resources 
; (list (list (quote :abstraction) "#P\"is a step or a repeat.omp\""))
(in-package :om)(load-lib-for (quote ("myextension")))(setf *om-current-persistent* (om-load-patch1 "leaps to octaves 2" (quote ((let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "mypatch" (quote ((let ((box (om-load-boxcall (quote abstraction) "process if there is a next chord and there are no null values" (om-load-patch-abs1 "process if there is a next chord and there are no null values" (quote ((let ((box (om-load-boxcall (quote abstraction) "first or second chord has null values" (om-load-patch-abs1 "first or second chord has null values" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 378 229) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 50 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 324 78) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMOR" (quote omor) (quote ((om-load-inputfun (quote input-funbox) "something" "SELF" nil) (om-load-inputfun (quote input-funbox) "other things" "REST" nil))) (om-make-point 345 188) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "HAS-NULL-VALUES 2" (quote t2l::has-null-values) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 364 141) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "HAS-NULL-VALUES" (quote t2l::has-null-values) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 274 141) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((3 0 0 0 nil 0) (1 0 2 0 nil 0) (5 0 3 0 nil 0) (4 0 3 1 nil 0) (2 1 4 0 nil 0) (2 0 5 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 503 334)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 1239/4 137) nil nil nil "first or second chord has null values"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 433 199) (om-make-point 26 28) (quote t) "T" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF 2" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 421 229) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 279 223) (om-make-point 26 28) (quote t) "T" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 259 253) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CDR" (quote cdr) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 235 205) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 114 232) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 93 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "process next chord" (om-load-patch-abs1 "process next chord" (quote ((let ((box (om-load-boxcall (quote abstraction) "voice1 and voice2" (om-load-patch-abs1 "voice1 and voice2" (quote ((let ((box (om-load-boxcall (quote abstraction) "is an octave or unison" (om-load-patch-abs1 "is an octave or unison" (quote ((let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 140 253) (om-make-point 26 28) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?=" (quote ?=) (quote ((om-load-inputfun (quote input-funbox) "" "X" nil) (om-load-inputfun (quote input-funbox) "" "Y" nil))) (om-make-point 130 283) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 118 189) (om-make-point 32 28) 12 "12" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?%" (quote ?%) (quote ((om-load-inputfun (quote input-funbox) "" "N" nil) (om-load-inputfun (quote input-funbox) "" "D" nil))) (om-make-point 106 219) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?ABS" (quote ?abs) (quote ((om-load-inputfun (quote input-funbox) "" "K" nil))) (om-make-point 96 168) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?-" (quote ?-) (quote ((om-load-inputfun (quote input-funbox) "" "X" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 76 112) (om-make-point 74 50) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "y" 1 (om-make-point 55 45) "" "y" 60 nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "x" 0 (om-make-point 172 46) "" "x" 67 nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 64 412) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((3 0 1 0 nil 0) (0 0 1 1 nil 0) (4 0 3 0 nil 0) (2 0 3 1 nil 0) (5 0 4 0 nil 0) (6 0 5 0 nil 0) (7 0 5 1 nil 0) (1 0 8 0 nil 0))) 6.16 nil "" (om-make-point 356 2) (om-make-point 500 380)) (quote ((om-load-inputfun (quote input-funbox) "" "x" 67) (om-load-inputfun (quote input-funbox) "" "y" 60))) (om-make-point 189 146) nil nil "&" "is an octave or unison"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is a step or a repeat" (quote ("elements" "strict polyphonic voice-motion" "is a step or a repeat")) (quote ((om-load-inputfun (quote input-funbox) "" "x1" nil) (om-load-inputfun (quote input-funbox) "" "x2" nil))) (om-make-point 519 230) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "is a step or a repeat" (quote ("elements" "strict polyphonic voice-motion" "is a step or a repeat")) (quote ((om-load-inputfun (quote input-funbox) "" "x1" nil) (om-load-inputfun (quote input-funbox) "" "x2" nil))) (om-make-point 398 231) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS 2" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 533 166) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS 2" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 412 165) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS 2" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 467 100) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 456 31) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?AND" (quote ?and) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 310 183) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?OR" (quote ?or) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 292 258) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?NOT" (quote ?not) (quote ((om-load-inputfun (quote input-funbox) "" "X" nil))) (om-make-point 235 222) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 215 81) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 74 73) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 200 357) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 88 0) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((10 0 0 0 nil 0) (10 1 0 1 nil 0) (3 0 1 0 nil 0) (3 1 1 1 nil 0) (4 0 2 0 nil 0) (4 1 2 1 nil 0) (5 1 3 0 nil 0) (5 0 4 0 nil 0) (6 0 5 0 nil 0) (13 0 6 0 nil 0) (0 0 7 0 nil 0) (2 0 7 1 nil 0) (1 0 7 2 nil 0) (9 0 8 0 nil 0) (7 0 8 1 nil 0) (0 0 9 0 nil 0) (11 1 10 0 nil 0) (13 0 11 0 nil 0) (8 0 12 0 nil 0))) 6.16 nil "" (om-make-point 502 146) (om-make-point 500 380)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 99 133) nil nil nil "voice1 and voice2"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CDR" (quote cdr) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 31 133) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 127 200) (om-make-point 26 28) (quote t) "T" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 107 230) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 19 315) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((5 0 0 0 nil 0) (5 0 1 0 nil 0) (1 0 3 0 nil 0) (0 0 3 1 nil 0) (2 0 3 2 nil 0) (3 0 4 0 nil 0))) 6.16 nil "" (om-make-point 583 47) (om-make-point 500 380)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 465 22) nil nil nil "process next chord"))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((7 0 0 0 nil 0) (0 0 2 0 nil 0) (1 0 2 1 nil 0) (8 0 2 2 nil 0) (5 0 4 0 nil 0) (2 0 4 1 nil 0) (3 0 4 2 nil 0) (7 0 5 0 nil 0) (4 0 6 0 nil 0) (7 0 8 0 nil 0))) 6.16 nil "" (om-make-point 656 37) (om-make-point 554 374)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 12 90) nil nil "l" "process if there is a next chord and there are no null values"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAPLIST?AND" (quote maplist?and) (quote ((om-load-inputfun (quote input-funbox) "" "FN" nil) (om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 186 192) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 239 128) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FLATTEN-SEQC" (quote flatten-seqc) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 235 83) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 16 356) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "voice1 voice2" 0 (om-make-point 165 10) "" "voice1 voice2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((0 0 1 0 nil 0) (2 0 1 1 nil 0) (3 0 2 0 nil 0) (5 0 3 0 nil 0) (1 0 4 0 nil 0))) 6.16 nil "" (om-make-point 214 35) (om-make-point 400 340)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 98 184) nil nil "l" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAP?AND" (quote map?and) (quote ((om-load-inputfun (quote input-funbox) "" "FN" nil) (om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 164 261) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "COMBINATIONS-OF2" (quote combinations-of2) (quote ((om-load-inputfun (quote input-funbox) "XS" "XS" nil))) (om-make-point 185 194) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 193 341) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 50 77) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((0 0 1 0 nil 0) (2 0 1 1 nil 0) (4 0 2 0 nil 0) (1 0 3 0 nil 0))) nil 6.16))