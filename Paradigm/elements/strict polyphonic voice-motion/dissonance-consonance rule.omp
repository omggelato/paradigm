; OM File Header - Saved 2023/10/27 23:11:17
; (6.16 :patc (om-make-point 69.0 610) (om-make-point 590 0) (om-make-point 822 452) "" 908 0 "2021/06/06 12:01:04" "2023/10/27 23:11:17")
; End File Header
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "dissonance-consonance rule" (quote ((let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "mypatch" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 117 505) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 2" 1 (om-make-point 326 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 50 113) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "lispfunction" (om-load-lisp-abspatch "lispfunction" 6.16 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (seqc-slices ivals%12 sequence)$  (let ((ival-is-dissonant-list (mapcar #'(lambda (x) (or (not x) (screamer:memberv x '(1 2 5 6 10 11)))) ivals%12))$        (cf (car sequence))$        (voice2 (cadr sequence)))$  (labels$        ((%12v (x) (if x (?% x 12) nil))$         (repeatv (x1 x2) (or (and (null x1) (null x2)) (?= x1 x2)))$         (is-stepv (x1 x2) $           (or (not (and x1 x2))$               (let ((d (?- x2 x1)))$                 (screamer:andv (?> d -2)$                                (?<= d 2)$                                (?/= x1 x2)))))$         (is-step-or-repeatv (x1 x2) $           (or (not (and x1 x2))$               (let ((d (?- x2 x1)))$                 (screamer:andv (?>= d -2)$                                (?<= d 2)))))$         (is-leapv (x1 x2) (?and (?/= x1 x2)$                                 (?not (is-stepv x1 x2)))))$    (let ((ivals%12 (mapcar #'(lambda (xs) (or (null (cadr xs)) (null (car xs)) (?% (?- (cadr xs) (car xs)) 12))) seqc-slices)))$      (apply #'screamer:andv ; delete$             (maplist $              #'(lambda (xs ivalisdis)$                  ;;;; y1 y2 (y3) ...$                  ;;;; x1 x2 (x3) ...$                  (let ((x1 (caar xs))$                        (x2 (cadar xs))$                        (x3 (caddar xs))$                        (y1 (caadr xs))$                        (y2 (cadadr xs))$                        (y3 (caddr (cadr xs))))$$                    $$                    ;;;; leap to consonance$                    (cond$                     ((null x1) t)$                     ((null x2) t)$                     ((null x3) t)$                     ((null y1) t)$                     ((null y2) t)$                     ((null y3) t)                 $                                ; not a suspension$                     ((and $                       x3$                       y3$                       (not (equalp x1 x2)) $                       (not (equalp y1 y2))) ; the second slice is both different notes$                      ; (print (format nil \"ivalisdis: ~A xs: ~A\" ivalisdis xs))$                      (screamer:orv$                       (screamer:notv (cadr ivalisdis))$                       (screamer:andv (cadr ivalisdis)$                                      (is-stepv x1 x2)$                                      (is-stepv x2 x3)$                                      (is-stepv y1 y2)$                                      (is-stepv y2 y3))))$$                     ((and (equalp x1 x2) x3) ; one note held over$                      (screamer:orv $                       (screamer:notv (cadr ivalisdis)) ; the second slice is consonant$                       (screamer:andv (cadr ivalisdis) ; the second slice is dissonant$                                      (screamer:notv (caddr ivalisdis)) ; the third slice is consonant$                                      (is-stepv x1 x2)$                                      (is-stepv x2 x3)$                                      (is-stepv y1 y2)$                                      (is-stepv y2 y3))))$$                     ((equalp x1 x2) ; (null x3) = no third slice$                      (screamer:notv (cadr ivalisdis)))$                    $                                        $                     (t $                      (screamer:orv$                       (screamer:andv$                        (cadr ivalisdis)$                        (is-step-or-repeatv x1 x2)$                        (is-step-or-repeatv x2 x3)$                        (is-step-or-repeatv y1 y2)$                        (is-step-or-repeatv y2 y3))$                       (screamer:notv (cadr ivalisdis)))))))$              seqc-slices$              ival-is-dissonant-list))))))") (quote ((om-load-inputfun (quote input-funbox) "" "SEQC-SLICES" nil) (om-load-inputfun (quote input-funbox) "" "IVALS%12" nil) (om-load-inputfun (quote input-funbox) "" "SEQUENCE" nil))) (om-make-point 361 398) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 181 233) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FLATTEN-SEQC" (quote t2l::flatten-seqc) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 143 183) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((3 0 0 0 nil 0) (4 0 3 0 nil 0) (1 0 3 1 nil 0) (2 0 3 2 nil 0) (5 0 4 0 nil 0) (2 0 5 0 nil 0))) 6.16 nil "" (om-make-point 200 0) (om-make-point 486 600)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 625/3 799/3) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 29 108) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 7 (om-make-point 825 45) "" "input" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 96 500) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "horizontal-intervals-scale-degrees" 6 (om-make-point 605 45) "" "horizontal-intervals-scale-degrees" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "horizontal-intervals%12" 5 (om-make-point 425 45) "" "horizontal-intervals%12" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "vertical-intervals%12" 4 (om-make-point 305 45) "" "vertical-intervals%12" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "voice-intervals" 3 (om-make-point 215 45) "" "voice-intervals" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "vertical-intervals" 2 (om-make-point 105 45) "" "vertical-intervals" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "voice2" 1 (om-make-point 55 45) "" "voice2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "cf" 0 (om-make-point 5 45) "" "cf" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (6 0 0 1 nil 0) (10 0 1 0 nil 0) (9 0 1 1 nil 0) (0 0 3 0 nil 0))) nil 6.16))