; OM File Header - Saved 2023/10/27 23:11:17
; (6.16 :patc (om-make-point 24 24) (om-make-point 50 50) (om-make-point 532 456) "" 908 0 "2023/10/26 12:32:17" "2023/10/27 23:11:17")
; End File Header
(in-package :om)(load-lib-for (quote ("myextension")))(setf *om-current-persistent* (om-load-patch1 "dissonance-consonance rule 3" (quote ((let ((box (om-load-boxcall (quote abstraction) "extract absolute value of vertical intervals m12 or null" (om-load-lisp-abspatch "extract absolute value of vertical intervals m12 or null" 6.16 ";;; Edit a valid LAMBDA EXPRESSION for \"seqc vertical intervals m12 or null\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (seqc-slices) ; after flatten-seqc -> mat-trans$  (mapcar #'(lambda (xs)$              (cond$               ((t2l::has-null-values xs) nil)$               (T (?abs (?- (cadr xs) (car xs))))))$          seqc-slices))") (quote ((om-load-inputfun (quote input-funbox) "" "SEQC-SLICES" nil))) (om-make-point 221 247) nil nil nil "extract absolute value of vertical intervals m12 or null"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 337 124) nil nil "&" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "subtract" (om-load-patch-abs1 "subtract" (quote ((let ((box (om-load-boxcall (quote genfun) "?ABS" (quote ?abs) (quote ((om-load-inputfun (quote input-funbox) "" "K" nil))) (om-make-point 232 251) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?-" (quote ?-) (quote ((om-load-inputfun (quote input-funbox) "" "X" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 264 191) (om-make-point 20 50) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 127 277) (om-make-point 31 28) nil "nil" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 107 307) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CAR 2" (quote car) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 240 120) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CADR 2" (quote cadr) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 180 120) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMAND" (quote omand) (quote ((om-load-inputfun (quote input-funbox) "something" "SELF" nil) (om-load-inputfun (quote input-funbox) "other things" "REST" nil))) (om-make-point 93 242) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CAR" (quote car) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 140 120) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CADR" (quote cadr) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 80 120) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 66 375) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 66 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (5 0 1 0 nil 0) (4 0 1 1 nil 0) (6 0 3 0 nil 0) (0 0 3 1 nil 0) (2 0 3 2 nil 0) (10 0 4 0 nil 0) (10 0 5 0 nil 0) (8 0 6 0 nil 0) (7 0 6 1 nil 0) (10 0 7 0 nil 0) (10 0 8 0 nil 0) (3 0 9 0 nil 0))) 6.16 nil "" (om-make-point 730 73) (om-make-point 500 380)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 301 57) nil (list nil) "l" "subtract"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?LIST%" (quote ?list%) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "VALUE" nil))) (om-make-point 549 194) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 571 164) (om-make-point 32 28) 12 "12" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "process dissonance-consonance rule " (om-load-lisp-abspatch "process dissonance-consonance rule " 6.16 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (seqc-slices ivals%12 sequence)$  (let ((ival-is-dissonant-list (mapcar #'(lambda (x) (or (not x) (screamer:memberv x '(1 2 5 6 10 11)))) ivals%12))$        (cf (car sequence))$        (voice2 (cadr sequence)))$  (labels$        ((%12v (x) (if x (?% x 12) nil))$         (repeatv (x1 x2) (or (and (null x1) (null x2)) (?= x1 x2)))$         (is-stepv (x1 x2) $           (or (not (and x1 x2))$               (let ((d (?- x2 x1)))$                 (screamer:andv (?> d -2)$                                (?<= d 2)$                                (?/= x1 x2)))))$         (is-step-or-repeatv (x1 x2) $           (or (not (and x1 x2))$               (let ((d (?- x2 x1)))$                 (screamer:andv (?>= d -2)$                                (?<= d 2)))))$         (is-leapv (x1 x2) (?and (?/= x1 x2)$                                 (?not (is-stepv x1 x2)))))$    (let ((ivals%12 (mapcar #'(lambda (xs) (or (null (cadr xs)) (null (car xs)) (?% (?- (cadr xs) (car xs)) 12))) seqc-slices)))$      (apply #'screamer:andv ; delete$             (maplist $              #'(lambda (xs ivalisdis)$                  ;;;; y1 y2 (y3) ...$                  ;;;; x1 x2 (x3) ...$                  (let ((x1 (caar xs))$                        (x2 (cadar xs))$                        (x3 (caddar xs))$                        (y1 (caadr xs))$                        (y2 (cadadr xs))$                        (y3 (caddr (cadr xs))))$$                    $$                    ;;;; leap to consonance$                    (cond$                     ((null x1) t)$                     ((null x2) t)$                     ((null x3) t)$                     ((null y1) t)$                     ((null y2) t)$                     ((null y3) t)                 $                                ; not a suspension$                     ((and $                       x3$                       y3$                       (not (equalp x1 x2)) $                       (not (equalp y1 y2))) ; the second slice is both different notes$                      ; (print (format nil \"ivalisdis: ~A xs: ~A\" ivalisdis xs))$                      (screamer:orv$                       (screamer:notv (cadr ivalisdis))$                       (screamer:andv (cadr ivalisdis)$                                      (is-stepv x1 x2)$                                      (is-stepv x2 x3)$                                      (is-stepv y1 y2)$                                      (is-stepv y2 y3))))$$                     ((and (equalp x1 x2) x3) ; one note held over$                      (screamer:orv $                       (screamer:notv (cadr ivalisdis)) ; the second slice is consonant$                       (screamer:andv (cadr ivalisdis) ; the second slice is dissonant$                                      (screamer:notv (caddr ivalisdis)) ; the third slice is consonant$                                      (is-stepv x1 x2)$                                      (is-stepv x2 x3)$                                      (is-stepv y1 y2)$                                      (is-stepv y2 y3))))$$                     ((equalp x1 x2) ; (null x3) = no third slice$                      (screamer:notv (cadr ivalisdis)))$                    $                                        $                     (t $                      (screamer:orv$                       (screamer:andv$                        (cadr ivalisdis)$                        (is-step-or-repeatv x1 x2)$                        (is-step-or-repeatv x2 x3)$                        (is-step-or-repeatv y1 y2)$                        (is-step-or-repeatv y2 y3))$                       (screamer:notv (cadr ivalisdis)))))))$              seqc-slices$              ival-is-dissonant-list))))))") (quote ((om-load-inputfun (quote input-funbox) "" "SEQC-SLICES" nil) (om-load-inputfun (quote input-funbox) "" "IVALS%12" nil) (om-load-inputfun (quote input-funbox) "" "SEQUENCE" nil))) (om-make-point 263 325) nil nil nil "process dissonance-consonance rule "))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FLATTEN-SEQC" (quote t2l::flatten-seqc) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 163 123) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 201 173) nil nil "&" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 0 302) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 0 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((7 0 0 0 nil 0) (2 0 1 0 nil 0) (7 0 1 1 nil 0) (1 0 3 0 nil 0) (4 0 3 1 nil 0) (7 0 5 0 nil 0) (0 0 5 1 nil 0) (9 0 5 2 nil 0) (9 0 6 0 nil 0) (6 0 7 0 nil 0) (5 0 8 0 nil 0))) nil 6.16))