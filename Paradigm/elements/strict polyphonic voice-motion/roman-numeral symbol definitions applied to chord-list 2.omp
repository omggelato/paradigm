; OM File Header - Saved 2022/11/30 5:16:05
; (6.16 :patc (om-make-point 24 24) (om-make-point 50 50) (om-make-point 256 358) "" 908 0 "2022/11/30 3:28:42" "2022/11/30 3:28:42")
; End File Header
(in-package :om)(load-lib-for (quote ("myextension")))(setf *om-current-persistent* (om-load-patch1 "roman-numeral symbol definitions applied to chord-list 2" (quote ((let ((box (om-load-boxcall (quote genfun) "MAPLIST2ANDV" (quote t2l::maplist2andv) (quote ((om-load-inputfun (quote input-funbox) "" "FN" nil) (om-load-inputfun (quote input-funbox) "" "LIST1" nil) (om-load-inputfun (quote input-funbox) "" "LIST2" nil))) (om-make-point 90 189) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "lispfunction" (om-load-lisp-abspatch "lispfunction" 6.16 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (chord-list chord-symbols transposition)$  (t2l::maplist2andv$   #'(lambda (chord-list chord-symbols)$       (labels$           ((transposition (pcset x)$              (t2l::list%v (t2l::list+v pcset $                                        (t2l::om+v x transposition)) 12))$$            (condition (sym variable)$              (cond $               ((null chord-list) T)$               ((null chord-symbols) T)$               (T$                (if (screamer:possibly? (screamer:solution$                                         (t2l::omequalv sym (car chord-symbols))$                                         (screamer:static-ordering #'screamer:linear-force)))$                    (progn$                      (t2l::alert2 (format nil \" > ~A - ~A?\" (car chord-symbols) sym))$                      (t2l::omorv (t2l::omnotv $                                   (t2l::omequalv sym (car chord-symbols)))$                                  (t2l::omandv$                                   (t2l::omequalv sym (car chord-symbols))$                                   variable)))$                  T))))$$            (triad (pcset)$              (let* ((variables (car chord-list))$                     (variables%12 (remove nil (t2l::list%v variables 12))))$              ; (t2l::alert2 (format nil \"     triad: ~A - ~A\" (t2l::variable-names-in variables) pcset))$                (t2l::omandv$                 (t2l::all-integer-items-inv variables%12 pcset)$                 (t2l::member-of-number-sequencev (car pcset) variables%12)$                 (t2l::member-of-number-sequencev (cadr pcset) variables%12)))) ; 3rd represented$$            (triad-inversion (pcset)$              ; (t2l::alert2 (format nil \"     triad64: ~A - ~A\" (t2l::variable-names-in variables) pcset))$              (let ((variables (car chord-list))$                    (variables%12 (remove nil (t2l::list%v variables 12))))$                (t2l::omandv $                 (t2l::all-integer-items-inv variables%12 pcset)$                 (t2l::om=v (t2l::%v (t2l::omminv variables) 12) (car pcset))$                 (t2l::member-of-number-sequencev (car pcset) variables%12)$                 (t2l::member-of-number-sequencev (cadr pcset) variables%12)$                 (t2l::member-of-number-sequencev (caddr pcset) variables%12)))) ; delete$$            (full-triad (pcset)$              ; (t2l::alert2 (format nil \"     full-triad: ~A - ~A\" (t2l::variable-names-in (car chord-list)) pcset))$              (let ((variables%12 (remove nil (t2l::list%v (car chord-list) 12))))$                (t2l::omandv$                 (t2l::all-integer-items-inv variables%12 pcset)$                 (t2l::all-integer-items-inv pcset variables%12))))$$            (minN7 (scale-degree%12)$              (let* ((chord (car chord-list))$                    (chord%12 (t2l::list%v chord 12))$                    (next-chord (cadr chord-list))$                    (pcset (transposition '(0 3 7 10) scale-degree%12)))$                ; (t2l::alert2 (format nil \"     minN7: ~A, next: ~A - ~A\" (t2l::variable-names-in (car chord-list)) (t2l::variable-names-in (cadr chord-list)) pcset))$                (cond $                 ((null chord) nil)            $                 ((null next-chord) nil)$                 (T $                  (t2l::omandv  $                   (t2l::all-integer-items-inv chord%12 pcset)$                   (t2l::all-integer-items-inv pcset chord%12)$                   (t2l::map2andv$                    #'(lambda (chord1-note chord2-note)$                        (let ((chord1-pc (if chord1-note (t2l::%v chord1-note 12)))$                              (chord2-pc (if chord2-note (t2l::%v chord2-note 12)))$                              (seventh-pc (last-elem pcset))$                              (third-pc (cadr pcset)))$                          (cond$                           ((null chord1-note) T)$$                    ; 7th can't pass to NULL$                           ((null chord2-note)$                            (t2l::omnotv $                             (t2l::=v chord1-pc seventh-pc)))$$                           (T$                            (t2l::omorv                         $                             (t2l::omandv $                              (t2l::omorv (t2l::notv (t2l::om=v chord1-pc seventh-pc))$                                          (t2l::omandv $                                           (t2l::om=v chord1-pc seventh-pc)$                                           (t2l::om=v chord2-note (t2l::om-v chord1-note (screamer:an-integer-betweenv 1 2)))))$                              (t2l::omorv (t2l::notv (t2l::om=v chord1-pc third-pc))$                                          (t2l::omandv $                                           (t2l::om=v chord1-pc third-pc)$                                           (t2l::om=v chord2-note (t2l::om+v chord1-note (screamer:an-integer-betweenv 1 2)))))))))))$                    chord$                    next-chord))))))$$            (majN7 (scale-degree%12)$              (let* ((chord (car chord-list))$                     (chord%12 (t2l::list%v chord 12))$                    (next-chord (cadr chord-list))$                    (pcset (transposition '(0 4 7 10) scale-degree%12)))$                ; (t2l::alert2 (format nil \"     majN7: ~A, next: ~A - ~A\" (t2l::variable-names-in (car chord-list)) (t2l::variable-names-in (cadr chord-list)) pcset))$                (cond $                 ((null chord) nil)            $                 ((null next-chord) nil)$                 (T $                  (t2l::omandv$                   $                   (t2l::all-integer-items-inv chord%12 pcset)$                   (t2l::all-integer-items-inv pcset chord%12)$$                   (t2l::map2andv$                    #'(lambda (chord1-note chord2-note)$                        (let ((chord1-pc (if chord1-note (t2l::%v chord1-note 12)))$                              (chord2-pc (if chord2-note (t2l::%v chord2-note 12)))$                              (seventh-pc (last-elem pcset))$                              (third-pc (cadr pcset)))$                          (cond$                           ((null chord1-note) T)$$                    ; 7th can't pass to NULL$                           ((null chord2-note)$                            (t2l::omnotv $                             (t2l::=v chord1-pc seventh-pc)))$$                           (T$                            (t2l::omorv                         $                             (t2l::omandv $                              (t2l::omorv (t2l::notv (t2l::om=v chord1-pc seventh-pc))$                                          (t2l::omandv $                                           (t2l::om=v chord1-pc seventh-pc)$                                           (t2l::om=v chord2-note (t2l::om-v chord1-note 1))))$                              (t2l::omorv (t2l::notv (t2l::om=v chord1-pc third-pc))$                                          (t2l::omandv $                                           (t2l::om=v chord1-pc third-pc)$                                           (t2l::om=v chord2-note (t2l::om+v chord1-note 1))))))))))$                    chord$                    next-chord))))))$$         (ita6 ()$           (let* ((chord (car chord-list))$                  (next-chord (if (cdr chord-list) (cadr chord-list)))$                  (pcset (transposition '(8 0 6) 0))$                  (chord%12 (t2l::list%v chord 12)))$             ; (t2l::alert2 (format nil \"     IT6: ~A next: ~A - ~A\" (t2l::variable-names-in chord) (t2l::variable-names-in next-chord) pcset))$             (cond $              ((null chord) nil)            $              ((null next-chord) nil)$              (T $               (t2l::omandv              $                (t2l::all-integer-items-inv chord%12 pcset)$                (t2l::all-integer-items-inv pcset chord%12)$                (t2l::map2andv$                 #'(lambda (chord1-note chord2-note)$                     (let ((chord1-pc (if chord1-note (t2l::%v chord1-note 12)))$                           (chord2-pc (if chord2-note (t2l::%v chord2-note 12)))$                           (fourth+pc (caddr pcset))$                           (sixth+pc (last-elem pcset))$                           (third-pc (cadr pcset)))$                       (cond$                        ((null chord1-note) T)$$                        ((null chord2-note)$                         (t2l::omandv$                          (t2l::notv (t2l::om=v chord1-pc (car pcset)))$                          (t2l::notv (t2l::om=v chord1-pc sixth+pc))))$$                        (T$                         (t2l::omorv$                      $                          (t2l::omandv $                           (t2l::omorv (t2l::notv (t2l::om=v chord1-pc (car pcset)))$                                       (t2l::omandv $                                        (t2l::om=v chord1-pc (car pcset))$                                        (t2l::om=v chord2-pc (t2l::om-v chord1-pc 1))))$                           (t2l::omorv (t2l::notv (t2l::om=v chord1-pc third-pc))$                                       (t2l::omandv $                                        (t2l::om=v chord1-pc third-pc)$                                        (t2l::om=v chord2-note (t2l::om-v chord1-note (screamer:an-integer-betweenv 1 2)))))$                           (t2l::omorv (t2l::omnotv (t2l::om=v chord1-pc fourth+pc)) ; delete (5ths repeat)$                                       (t2l::om=v chord1-pc fourth+pc)$                                       (t2l::om=v chord1-note chord2-note))$                           (t2l::omorv (t2l::omnotv (t2l::om=v chord1-pc sixth+pc))$                                       (t2l::omandv $                                        (t2l::om=v chord1-pc sixth+pc)$                                        (t2l::om=v chord2-note (t2l::om+v chord1-note 1))))))))))$                 chord$                 next-chord))))))$$         (fra6 ()$           (let* ((chord (car chord-list))$                  (next-chord (if (cdr chord-list) (cadr chord-list)))$                  (pcset (transposition '(8 0 2 6) 0))$                  (chord%12 (t2l::list%v chord 12)))             $             ; (t2l::alert2 (format nil \"     FR6 ~A next: ~A - ~A\" (t2l::variable-names-in chord) (t2l::variable-names-in next-chord) pcset))$             (cond $              ((null chord) nil)            $              ((null next-chord) nil)$              (T $               (t2l::omandv    $                   $                (t2l::all-integer-items-inv chord%12 pcset)$                (t2l::all-integer-items-inv pcset chord%12)$$                (t2l::map2andv$                 #'(lambda (chord1-note chord2-note)$                     (let ((chord1-pc (if chord1-note (t2l::%v chord1-note 12)))$                           (chord2-pc (if chord2-note (t2l::%v chord2-note 12)))$                           (sixth+pc (last-elem pcset))$                           (fourth+pc (caddr pcset))$                           (third-pc (cadr pcset)))$                       (cond$                        ((null chord1-note) T)$$                        ((null chord2-note)$                         (t2l::omandv$                          (t2l::notv (t2l::om=v chord1-pc (car pcset)))$                          (t2l::notv (t2l::om=v chord1-pc sixth+pc))))$$                        (T$                         (t2l::omorv$$                          (t2l::omandv $                           (t2l::omorv (t2l::notv (t2l::om=v chord1-pc (car pcset)))$                                       (t2l::omandv $                                        (t2l::om=v chord1-pc (car pcset))$                                        (t2l::om=v chord2-pc (t2l::om-v chord1-pc 1))))$                           (t2l::omorv (t2l::notv (t2l::om=v chord1-pc third-pc))$                                       (t2l::omandv $                                        (t2l::om=v chord1-pc third-pc)$                                        (t2l::omorv$                                         (t2l::om=v chord2-note (t2l::om+v chord1-note 2))$                                         (t2l::om=v chord2-note (t2l::om-v chord1-note (screamer:an-integer-betweenv 1 2))))))$                           (t2l::omorv (t2l::omnotv (t2l::om=v chord1-pc fourth+pc))                                     $                                       (t2l::om=v chord1-pc fourth+pc)$                                       (t2l::om=v chord1-note chord2-note))$                           (t2l::omorv (t2l::omnotv (t2l::om=v chord1-pc sixth+pc))$                                       (t2l::omandv $                                        (t2l::om=v chord1-pc sixth+pc)$                                        (t2l::om=v chord2-note (t2l::om+v chord1-note 1))))))))))$                 chord$                 next-chord))))))$$         (ger6 ()$           (let* ((chord (car chord-list))$                 (next-chord (if (cdr chord-list) (cadr chord-list)))$                 (pcset (transposition '(8 0 3 6) 0))$                 (chord%12 (t2l::list%v chord 12)))$             ; (t2l::alert2 (format nil \"     GER6: ~A next: ~A - ~A\" (t2l::variable-names-in chord) (t2l::variable-names-in next-chord) pcset))$             (cond $              ((null chord) nil)            $              ((null next-chord) nil)$              (T $               (t2l::omandv     $                   $                (t2l::all-integer-items-inv chord%12 pcset)$                (t2l::all-integer-items-inv pcset chord%12)  $$                (t2l::map2andv$                 #'(lambda (chord1-note chord2-note)$                     (let ((chord1-pc (if chord1-note (t2l::%v chord1-note 12)))$                           (chord2-pc (if chord2-note (t2l::%v chord2-note 12)))$                           (sixth+pc (last-elem pcset))$                           (third-pc (cadr pcset))$                           (fourth-pc (caddr pcset)))$                       (cond$                        ((null chord1-note) T)$$                        ((null chord2-note)$                         (t2l::omnotv $                          (t2l::=v chord1-pc nil)))$$                        (T$                         (t2l::omorv                         $                          (t2l::omandv $                           (t2l::omorv (t2l::notv (t2l::om=v chord1-pc sixth+pc))$                                       (t2l::omandv $                                        (t2l::om=v chord1-pc sixth+pc)$                                        (t2l::om=v chord2-note (t2l::om+v chord1-note 1))))$                           (t2l::omorv (t2l::notv (t2l::om=v chord1-pc third-pc))$                                       (t2l::omandv $                                        (t2l::om=v chord1-pc third-pc)$                                        (t2l::om=v chord2-note (t2l::om-v chord1-note (screamer:an-integer-betweenv 1 2)))))$                           (t2l::omorv (t2l::notv (t2l::om=v chord1-pc (caddr pcset))) ;5th$                                       (t2l::om=v chord1-note chord2-note)) ; delete$                           (t2l::omorv (t2l::om/=v chord1-pc (car pcset))$                                       (t2l::omandv $                                        (t2l::om=v chord1-pc (car pcset))$                                        (t2l::om=v chord2-note (t2l::om-v chord1-note 1))))))))))$                 chord$                 next-chord))))))$         $         (neapolitan ()$           ; (t2l::alert2 (format nil \"     neapolitan: ~A \" (t2l::variable-names-in (car chord-list))))$           (let ((pcset (transposition '(5 8 1) 0)))$             (t2l::all-integer-items-inv (car chord-list) pcset))))$         (t2l::alert2 (format nil \"~A (~A):\" (car chord-symbols) (car chord-list)))$          (t2l::omorv$           (condition 'i (triad (transposition '(0 4 7) 0))) $           (condition 'i63 (triad (transposition '(4 7 0) 0)))$           (condition 'i64 (triad (transposition '(7 0 4) 0)))$           (condition 'ii (triad (transposition '(0 3 7) 2)))$           (condition 'iii (triad (transposition '(0 3 7) 3)))$           (condition 'iv (triad (transposition '(0 4 7) 5)))$           (condition 'iv7 (majN7 5))$           (condition 'v (triad (transposition '(0 4 7) 7)))$           (condition 'v7 (majN7 7))$           (condition 'vi (triad (transposition '(0 3 7) 8)))$           (condition 'vii (full-triad (transposition '(0 3 6) 19)))$           (condition 'v/v (triad (transposition '(0 4 7) 2)))$           (condition 'im (triad (transposition '(0 3 7) 0))) $           (condition 'i63m (triad (transposition '(3 7 0) 0)))$           (condition 'i64m (triad (transposition '(7 0 3) 0)))$           (condition 'iim (triad (transposition '(0 3 6) 2)))$           (condition 'iiim (triad (transposition '(0 4 7) 3)))$           (condition 'ivm (triad (transposition '(0 3 7) 5)))$           (condition 'iv7m (minN7 5))$           (condition 'iv7m+ (majN7 5))$           (condition 'vm (triad (transposition '(0 3 7) 7)))$           (condition 'vm7 (minN7 7))$           (condition 'vm+ (triad (transposition '(0 4 7) 7)))$           (condition 'vm7+ (majN7 7))$           (condition 'vim (triad (transposition '(0 4 7) 8)))           $           (condition 'viim (triad (transposition '(0 3 7) 19)))$           (condition 'v/vm (triad (transposition '(0 3 7) 2)))$           (condition 'it6 (ita6))$           (condition 'fr6 (fra6))$           (condition 'de6 (ger6))$           (condition 'n (neapolitan))$           (condition 'nm (neapolitan)))))$   chord-list$   chord-symbols))") (quote ((om-load-inputfun (quote input-funbox) "" "CHORD-LIST" nil) (om-load-inputfun (quote input-funbox) "" "CHORD-SYMBOLS" nil) (om-load-inputfun (quote input-funbox) "" "TRANSPOSITION" nil))) (om-make-point 6 94) nil nil "l" "lispfunction"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "transposition" 2 (om-make-point 39 31) "" "transposition" 0 nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 70 256) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "symbols" 1 (om-make-point 448/3 117) "" "symbols" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord-list" 0 (om-make-point 92 118) "" "chord-list" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (5 0 0 1 nil 0) (4 0 0 2 nil 0) (2 0 1 2 nil 0) (0 0 3 0 nil 0))) nil 6.16))
