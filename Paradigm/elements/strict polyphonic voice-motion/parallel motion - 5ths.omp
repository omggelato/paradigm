; OM File Header - Saved 2022/11/18 21:03:22
; (6.16 :patc (om-make-point 603.9844 610) (om-make-point 730 15) (om-make-point 502 500) "" 908 0 "2022/11/15 20:01:44" "2022/11/18 21:03:22")
; End File Header
(in-package :om)(load-lib-for (quote ("myextension")))(setf *om-current-persistent* (om-load-patch1 "parallel motion - 5ths" (quote ((let ((box (om-load-boxcall (quote abstraction) "lispfunction" (om-load-lisp-abspatch "lispfunction" 6.16 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (chord-interval-list-pair)$  (let ((ch1 (car chord-interval-list-pair))$        (ch2 (cadr chord-interval-list-pair)))$    (apply$     #'t2l::omandv$     (mapcar #'(lambda (x)$                 (t2l::omorv $                  (t2l::omnotv (t2l::om=v x 7))$                  (t2l::omandv (t2l::om=v x 7)$                               (t2l::list/=v ch2 7))))$             ch1))))$                            ") (quote ((om-load-inputfun (quote input-funbox) "" "CHORD-INTERVAL-LIST-PAIR" nil))) (om-make-point 27 370) nil (list nil) "l" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "print message" (om-load-lisp-abspatch "print message" 6.16 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (xs)$  (print (format nil \"PARALLEL-MOTION-3X: evaluating ~A\" xs))$  (print (format nil \"PARALLEL-MOTION-3X: ~A variables\" (length xs)))$  xs)") (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 133 511) nil nil nil "print message"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMANDV" (quote t2l::omandv) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 147 584) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 163 449) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR 2" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 80 444) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "COMBINATIONS-OF2" (quote t2l::combinations-of2) (quote ((om-load-inputfun (quote input-funbox) "XS" "XS" nil))) (om-make-point 243 168) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "remove note pairs that have null values" (om-load-patch-abs1 "remove note pairs that have null values" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 5 240) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR 4" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 127 163) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "HAS-NULL-VALUES" (quote t2l::has-null-values) (quote ((om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 50 50) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REMOVE-IF" (quote remove-if) (quote ((om-load-inputfun (quote input-funbox) "PREDICATE" "PREDICATE" nil) (om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 87 113) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 0 0 nil 0) (4 0 2 0 nil 0) (1 0 2 1 nil 0) (3 0 4 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 73 569/3) nil (list nil) "l" "remove note pairs that have null values"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR 5" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 176 264) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "interval%12" (om-load-patch-abs1 "interval%12" (quote ((let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 192 93) nil nil "&" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAP-FUNC 2" (quote t2l::map-func) (quote ((om-load-inputfun (quote input-funbox) "FN" "FN" nil) (om-load-inputfun (quote input-funbox) "TREE" "TREE" nil))) (om-make-point 47 299) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAP-FUNC" (quote t2l::map-func) (quote ((om-load-inputfun (quote input-funbox) "FN" "FN" nil) (om-load-inputfun (quote input-funbox) "TREE" "TREE" nil))) (om-make-point 195 384) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 196 307) (om-make-point 32 28) 12 "12" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "%V" (quote t2l::%v) (quote ((om-load-inputfun (quote input-funbox) "N" "N" nil) (om-load-inputfun (quote input-funbox) "D" "D" nil))) (om-make-point 182 337) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ABSV" (quote t2l::absv) (quote ((om-load-inputfun (quote input-funbox) "K" "K" nil))) (om-make-point 25 250) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS 2" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 141 160) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 84 229) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-V" (quote t2l::om-v) (quote ((om-load-inputfun (quote input-funbox) "" "X" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 27 168) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 61 160) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 5 450) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "all combinations of two notes in a chord" 0 (om-make-point 95 32) "" "all combinations of two notes in a chord" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((11 0 0 0 nil 0) (5 0 1 0 nil 0) (7 0 1 1 nil 0) (4 0 2 0 nil 0) (1 0 2 1 nil 0) (3 0 4 1 nil 0) (0 0 6 0 nil 0) (8 0 7 0 nil 0) (9 1 7 1 nil 0) (6 0 7 2 nil 0) (0 0 9 0 nil 0) (2 0 10 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 380)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 20 239) nil (list nil) "l" "interval%12"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR 3" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 59 312) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 282 212) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch 2" (om-load-patch-abs1 "mypatch" (quote ((let ((box (om-load-boxcall (quote lispfun) "MAPCAR" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 62 263) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "compare1" (om-load-patch-abs1 "compare1" (quote ((let ((box (om-load-boxcall (quote lispfun) "MAPCAR" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 140 195) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "compare chord2 against interval" (om-load-patch-abs1 "compare chord2 against interval" (quote ((let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 154 123) (om-make-point 26 28) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM/=V 2" (quote t2l::om/=v) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 148 153) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 84 123) (om-make-point 26 28) 7 "7" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM/=V" (quote t2l::om/=v) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 78 153) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMANDV 3" (quote t2l::omandv) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 108 209) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "interval2" 1 (om-make-point 175 37) "" "interval2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 133 267) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "interval1" 0 (om-make-point 50 50) "" "interval1" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((0 0 1 0 nil 0) (7 0 1 1 nil 0) (5 0 1 2 nil 0) (2 0 3 0 nil 0) (7 0 3 1 nil 0) (5 0 3 2 nil 0) (3 0 4 0 nil 0) (1 0 4 1 nil 0) (4 0 6 0 nil 0))) 6.16 nil "" (om-make-point 655 146) (om-make-point 313 271)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 31 111) nil nil "l" "compare chord2 against interval"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 30 258) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord2 intervals" 1 (om-make-point 185 45) "" "chord2 intervals" (list 0 5 7) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "interval" 0 (om-make-point 135 45) "" "interval" 4 nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (3 0 0 1 nil 0) (4 0 1 1 nil 0) (0 0 2 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 400 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 27 183) nil (list nil) "l" "compare1"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS 3" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 67 114) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 5 334) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord-intervals-list-pair" 0 (om-make-point 5 45) "" "chord-intervals-list-pair" (list (list 7 0 5) (list 3 10 7)) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (2 1 0 1 nil 0) (2 0 1 1 nil 0) (4 0 2 0 nil 0) (0 0 3 0 nil 0))) 6.16 nil "" (om-make-point 398 40) (om-make-point 252 312)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 374 272) nil (list nil) "l" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 159 350) (om-make-point 26 28) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 130 350) (om-make-point 26 28) 2 "2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "NSUCC" (quote t2l::nsucc) (quote ((om-load-inputfun (quote input-funbox) "" "INPUT" nil) (om-load-inputfun (quote input-funbox) "" "N" nil) (om-load-inputkeyword (quote input-keyword) "" "step" (quote :step) nil nil))) (om-make-point 116 380) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 352 149) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FLATTEN-SEQC" (quote t2l::flatten-seqc) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 348 104) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 0 640) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "sequence" 0 (om-make-point 0 34) "" "sequence" (list (list 48 48 48 48) (list 48 48 48 48) (list 48 48 48 48) (list 48 48 48 48)) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((3 0 1 0 nil 0) (1 0 2 0 nil 0) (4 0 3 0 nil 0) (0 0 4 0 nil 0) (14 0 4 1 nil 0) (6 0 7 0 nil 0) (10 0 7 1 nil 0) (8 0 9 0 nil 0) (7 0 9 1 nil 0) (5 0 10 0 nil 0) (15 0 10 1 nil 0) (9 0 14 0 nil 0) (13 0 14 1 nil 0) (12 0 14 2 nil 0) (16 0 15 0 nil 0) (18 0 16 0 nil 0) (2 0 17 0 nil 0))) nil 6.16))