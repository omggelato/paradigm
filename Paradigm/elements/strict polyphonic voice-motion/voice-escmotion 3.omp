; OM File Header - Saved 2023/10/27 23:11:18
; (6.16 :patc (om-make-point 280 110) (om-make-point 50 50) (om-make-point 500 300) "" 908 0 nil "2023/10/27 23:11:18")
; End File Header
(in-package :om)(load-lib-for (quote ("myextension")))(setf *om-current-persistent* (om-load-patch1 "voice-escmotion 3" (quote ((let ((box (om-load-boxin "rule-definition fn" 2 (om-make-point 216 24) "" "rule-definition fn" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "select-motion-type fn" 1 (om-make-point 95 25) "" "select-motion-type fn" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAP?AND" (quote map?and) (quote ((om-load-inputfun (quote input-funbox) "" "FN" nil) (om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 146 241) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "rule definition template" (om-load-patch-abs1 "rule definition template" (quote ((let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 21 210) (om-make-point 24 28) (quote t) "t" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 5 240) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((0 0 1 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 351 246) (om-make-point 77 66) nil "l" "rule definition template"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "voice1 and voice2 escmotion" (om-load-patch-abs1 "voice1 and voice2 escmotion" (quote ((let ((box (om-load-boxcall (quote genfun) "MAP?AND" (quote map?and) (quote ((om-load-inputfun (quote input-funbox) "" "FN" nil) (om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 85 301) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REMOVE-IF-NOT" (quote remove-if-not) (quote ((om-load-inputfun (quote input-funbox) "PREDICATE" "PREDICATE" nil) (om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 51 248) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "GROUP-BY-MOTION-TYPE" (quote group-by-motion-type) (quote ((om-load-inputfun (quote input-funbox) "" "VOICE1" nil) (om-load-inputfun (quote input-funbox) "" "VOICE2" nil))) (om-make-point 57 187) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "rule-definition" 2 (om-make-point 217 46) "" "rule-definition" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "select-fn" 1 (om-make-point 161 47) "" "select-fn" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 83 118) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 60 385) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((3 0 0 0 nil 0) (1 0 0 1 nil 0) (4 0 1 0 nil 0) (2 0 1 1 nil 0) (5 0 2 0 nil 0) (5 1 2 1 nil 0) (7 0 5 0 nil 0) (0 0 6 0 nil 0))) 6.16 nil "" (om-make-point 474 93) (om-make-point 500 320)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil) (om-load-inputfun (quote input-funbox) "" "input 3" nil))) (om-make-point 47 161) nil nil "l" "voice1 and voice2 escmotion"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "COMBINATIONS-OF2" (quote t2l::combinations-of2) (quote ((om-load-inputfun (quote input-funbox) "XS" "XS" nil))) (om-make-point 192 185) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "select motion type template" (om-load-lisp-abspatch "select motion type template" 6.16 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (input)$  ;; filter-by-motion-type$  T)") (quote ((om-load-inputfun (quote input-funbox) "" "INPUT" nil))) (om-make-point 314 176) nil nil "l" "select motion type template"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 88 245) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "sequence" 0 (om-make-point 21 27) "" "sequence" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((4 0 2 0 nil 0) (5 0 2 1 nil 0) (1 0 4 1 nil 0) (0 0 4 2 nil 0) (8 0 5 0 nil 0) (2 0 7 0 nil 0))) nil 6.16))