; OM File Header - Saved 2023/10/27 23:11:18
; (6.16 :patc (om-make-point 1161.9688 490) (om-make-point 788 101) (om-make-point 374 402) "processes sequences containing more than 2 voices" 908 0 "2022/11/16 3:05:47" "2023/10/27 23:11:18")
; End File Header
(in-package :om)(load-lib-for (quote ("myextension")))(setf *om-current-persistent* (om-load-patch1 "voice-overlap rule - 1-input" (quote ((let ((box (om-load-boxcall (quote abstraction) "has 1 voice or is null" (om-load-patch-abs1 "has 1 voice or is null" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 127 219) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 93 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM<=" (quote om<=) (quote ((om-load-inputfun (quote input-funbox) "a number" "NUM1" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM2" 1))) (om-make-point 75 192) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 93 158) (om-make-point 26 28) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 50 133) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 0 0 nil 0) (4 0 2 0 nil 0) (3 0 2 1 nil 0) (1 0 4 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 252 344)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 77/3 117) nil nil nil "has 1 voice or is null"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 102 178) (om-make-point 26 28) (quote t) "T" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 100 208) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "process sequence" (om-load-patch-abs1 "process sequence" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 131 273) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 116 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "process successive pairs of voices" (om-load-patch-abs1 "process successive pairs of voices" (quote ((let ((box (om-load-boxcall (quote genfun) "MAPLIST?AND" (quote maplist?and) (quote ((om-load-inputfun (quote input-funbox) "" "FN" nil) (om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 237 238) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 331 162) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "the highest note of one chord above the lowest of the next" (om-load-patch-abs1 "the highest note of one chord above the lowest of the next" (quote ((let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 653/7 1291/7) (om-make-point 26 28) (quote t) "T" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 513/7 1501/7) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CDR" (quote cdr) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 212/7 1116/7) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "process chord list" (om-load-patch-abs1 "process chord list" (quote ((let ((box (om-load-boxcall (quote abstraction) "this and next list do not contain null" (om-load-patch-abs1 "this and next list do not contain null" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 203 306) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 50 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?AND 2" (quote ?and) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 261 207) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 238 86) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?ALL<= 2" (quote ?all<=) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 286 146) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?ALL<=" (quote ?all<=) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 226 146) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "min-max of chord1 and chord2" (om-load-patch-abs1 "min-max of chord1 and chord2" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 19 351) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 120 0) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?LISTMAX" (quote ?listmax) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 14 134) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?LISTMIN" (quote ?listmin) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 57 134) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?<" (quote ?<) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 41 196) (om-make-point 27 50) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?>" (quote ?>) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 132 198) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?NOT" (quote ?not) (quote ((om-load-inputfun (quote input-funbox) "" "X" nil))) (om-make-point 126 253) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?NOT 2" (quote ?not) (quote ((om-load-inputfun (quote input-funbox) "" "X" nil))) (om-make-point 39 253) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?AND" (quote ?and) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil) (om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 79 293) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 26 68) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?LISTMIN 2" (quote ?listmin) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 107 134) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "?LISTMAX 2" (quote ?listmax) (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 144 134) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS 2" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 116 68) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((8 0 0 0 nil 0) (9 0 2 0 nil 0) (9 1 3 0 nil 0) (2 0 4 0 nil 0) (3 0 4 1 nil 0) (10 0 5 0 nil 0) (11 0 5 1 nil 0) (5 0 6 0 nil 0) (4 0 7 0 nil 0) (7 0 8 0 nil 0) (6 0 8 1 nil 0) (1 0 9 0 nil 0) (12 0 10 0 nil 0) (12 1 11 0 nil 0) (1 0 12 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 4159/11 1843/11) nil nil nil "min-max of chord1 and chord2"))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 0 0 nil 0) (5 0 2 0 nil 0) (4 0 2 1 nil 0) (6 0 2 2 nil 0) (1 0 3 0 nil 0) (3 1 4 0 nil 0) (3 0 5 0 nil 0) (1 0 6 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 5534/11 431)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 2506/11 5418/55) nil nil nil "this and next list do not contain null"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "print variables info" (om-load-lisp-abspatch "print variables info" 6.16 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (xs)$  (if (cdr xs)$      (print (format nil \"processing ~A and ~A\" (car xs) (cadr xs)))$    (print (format nil \"not processing ~A\" xs)))$  xs)") (quote ((om-load-inputfun (quote input-funbox) "" "XS" nil))) (om-make-point 331 34) nil nil nil "print variables info"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMOR 2" (quote omor) (quote ((om-load-inputfun (quote input-funbox) "something" "SELF" nil) (om-load-inputfun (quote input-funbox) "other things" "REST" nil))) (om-make-point 118 286) (om-make-point 98 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "HAS-NULL-VALUES 2" (quote t2l::has-null-values) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 80 185) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "HAS-NULL-VALUES" (quote t2l::has-null-values) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 0 185) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMOR" (quote omor) (quote ((om-load-inputfun (quote input-funbox) "something" "SELF" nil) (om-load-inputfun (quote input-funbox) "other things" "REST" nil))) (om-make-point 44 236) (om-make-point 82 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS 2" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 35 98) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 0 335) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chords" 0 (om-make-point 0 30) "" "chords" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((8 0 0 0 nil 0) (8 0 1 0 nil 0) (5 0 2 0 nil 0) (0 0 2 1 nil 0) (6 1 3 0 nil 0) (6 0 4 0 nil 0) (4 0 5 0 nil 0) (3 0 5 1 nil 0) (8 0 6 0 nil 0) (2 0 7 0 nil 0))) 6.16 nil "" (om-make-point 502 41) (om-make-point 500 340)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 1557/7 897/7) nil nil nil "process chord list"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 264 36) (quote "ex ((x1 nil) (x2 y2) (x3 y3) ...") "" (om-make-point 93 32) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chords" 0 (om-make-point 26 47) "" "chords" (list (list (quote x1) (quote x2)) (list (quote y1) (quote y2))) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 0 280) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 1 0 nil 0) (3 0 1 1 nil 0) (0 0 1 2 nil 0) (5 0 2 0 nil 0) (5 0 3 0 nil 0) (1 0 6 0 nil 0))) 6.16 nil "" (om-make-point 791 216) (om-make-point 500 340)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 0 154) nil (list nil) "l" "the highest note of one chord above the lowest of the next"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 212 306) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "two voices" 0 (om-make-point 248 44) "" "two voices" (list (list 60 62 (list 64 65) 67) (list 72 71 72 67)) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FLATTEN-SEQC" (quote t2l::flatten-seqc) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 327 115) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 0 0 nil 0) (1 0 0 1 nil 0) (5 0 1 0 nil 0) (0 0 3 0 nil 0) (4 0 5 0 nil 0))) 6.16 nil "" (om-make-point 440 0) (om-make-point 500 384)) (quote ((om-load-inputfun (quote input-funbox) "" "two voices" nil))) (om-make-point 50 817/7) nil nil "l" "process successive pairs of voices"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 260 94) (om-make-point 26 28) 2 "2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 289 94) (om-make-point 26 28) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "NSUCC" (quote nsucc) (quote ((om-load-inputfun (quote input-funbox) "" "INPUT" nil) (om-load-inputfun (quote input-funbox) "" "N" nil) (om-load-inputkeyword (quote input-keyword) "" "step" (quote :step) nil nil))) (om-make-point 246 124) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAP?AND" (quote map?and) (quote ((om-load-inputfun (quote input-funbox) "" "FN" nil) (om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 150 208) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((6 0 0 0 nil 0) (1 0 5 0 nil 0) (3 0 5 1 nil 0) (4 0 5 2 nil 0) (2 0 6 0 nil 0) (5 0 6 1 nil 0))) 6.16 nil "" (om-make-point 552 199) (om-make-point 414 338)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 149 4072/35) nil nil nil "process sequence"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 81 272) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "sequence" 0 (om-make-point 66 39) "" "sequence" (list (list 60 62 64) (list 67 65 67) (list 70 69 67)) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((5 0 0 0 nil 0) (0 0 2 0 nil 0) (1 0 2 1 nil 0) (3 0 2 2 nil 0) (5 0 3 0 nil 0) (2 0 4 0 nil 0))) nil 6.16))